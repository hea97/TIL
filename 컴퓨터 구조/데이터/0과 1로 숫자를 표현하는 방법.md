# 정보 단위

0과 1을 나타내는 가장 작은 정보 단위 **비트(bit).**  
비트는 전구에 빗대어 생각해보면 쉽다. 전구 한 개로 (꺼짐) 혹은 (켜짐), 두 가지 상태를 표현할 수 있듯 1 비트는 0또는 1, 두 가지 정보를 표현.

---

**비트** 0과 1을 표현 할수 있는 가장 적은 정보 단위

---

2비트는 몇 개의 정보를 표현할 수 있을까?  
왼쪽과같은 두 개의 친구가(꺼짐, 꺼짐), (꺼짐, 켜짐), (켜짐, 꺼짐), (켜짐, 켜짐), 네 가지 상태를 표현할 수 있는 것처럼 2비트는 네 가지 정보를 표현.

n개의 전구로 표현할 수 있는 상태는 2(n)가지입니다. 같은 개념 n비트는 2(n)가지 정보를 표현

실행하는 모든 프로그램은 수십만, 수백만 개 이상의 0과 1로 이루어져 있다. 프로그램의 크기를 말할 때는 표현의 편의를 위해 비트보다 큰 단위를 사용. 이러한 단위가 바로 바이트, 킬로바이트, 메가바이트, 기가바이트, 테라바이트

**바이트(byte)**는 여덟 개의 비트를 묶은 단위, 비트보다 한 단계 큰 단위.  
1바이트는 8바이트와 같으니 2(8) (256)개의 정보를 표현, 바이트 또한 더큰 단위로 묶을 수 있는데, 1바이트 1,000개를 묶은 단위를 1**킬로바이트(KB: kilobyte)**. 그리고 1킬로바이트 1,000개를 묶은 단위를 1**메가바이트(MB: megabyte),** 1메가바이트 1,000개를 묶은 단위를 1**기가바이트(GB: gigabyte)**, 1기가바이트 1,000개를 묶은 단위 1**테라바이트(TB: terabyte)**라고 한다.  
테라 바이트보다 더 큰 단위도 있으나 다루게 될 크기는 최대 테라바이트까지인 경우 많음.

| 1바이트(1byte) | 8비트(8bit) |
| --- | --- |
| 1킬로바이트(1KB) | 1,000바이트(1,000byte) |
| 1메가바이트(1MB) | 1,000킬로바이트(1,000KB) |
| 1기가바이트(1GB) | 1,000메가바이트(1,000MB) |
| 1테라바이트(1TB) | 1,000기가바이트(1,000GB) |

---

중요한 정보 단위 중 워드라는 단위도 있다.  
**워드(word)**란 CPU가 한 번에 처리할 수 있는 데이터 크기를 의미.  
만약 CPU가 한 번에 16비트를 처리할 수 있다면 1워드는 16비트가 되고, 한 번에 32비트를 처리할 수 있다면 1워드 32비트가 되는 것.

이렇게 정의된 워드의 절반 크기를 **하프 워드(half word)**, 1크기를 **풀 워드(full word)**, 2크기를 **더블 워드(double word)**라고 부름. 워드 크기가 큰 CU는 한 번에 처리할 수 있는 데이터가 많음.  
워드 크기는 CPU마다 다르지만, 현대 컴퓨터의 워드 크기는 대부분 32비트 64비트.  
가령 인텔의 x86 CPU는 32비트 워드 CPU, x64 CPU는 64비트 워드 CPU

---

# 이진법

0과 1만으로 숫자를 표현하는 방법.  
수학에서 0과 1만 모든 숫자를 표현하는 방법 **이진법(binary)**이라고 한다. 이진법을 이용하면 1보다 큰 수도 0과 1만으로 표현.  
숫자가 1을 넘어가는 시점에 자리 올림을 하면 된다

보통 숫자를 셀 때 09를 넘어가는 시점에 자리 올림을 한다. 9 다음이 10, 19 다음에 20인 것처럼.  
이는 일상적으로 **십진법(decimal)**을 사용. 십진법은 숫자가 9를 넘어가는 시점에 자리 올림을 하여 0부터 9까지, 열 개의 숫자만으로 모든 수를 표현.

이진법은 아래와 같이 숫자가 1을 넘어가는 시점에 자리 올림을 하여 0과 1, 두 개의 숫자만으로 모든 수를 표현

| 십진수 | 이진수 |
| --- | --- |
| 1 | 1 |
| 2 | 10 |
| 3 | 11 |
| 4 | 100 |
| 5 | 101 |
| 6 | 110 |
| 7 | 111 |
| 8 | 1000 |

이진법으로 표현한 수를 **이진수,** 십진법으로 표현한 수를 **십진수**.  
일상적으로 십진수, 0과 1밖에 모르는 컴퓨터에 어떤 숫자를 알려 주려면 십진수가 아닌 이진수로 알려 주어야한다. 십진수 2를 컴퓨터에 알려 주려면 이진수로 표현한 10을 알려주면 된다. 그리고 십진수 8을 컴퓨터에 알려 주려면 이진수로 표현한 1000을 알려 주면 된다.

## 이진수의 음수 표현

십진수 음수를 표현할 땐 단순히 숫자 앞에 마이너스 부호 붙이면 그만. -1, -3, -5. . . 이런식.  
이진수도 똑같이 마이너스 부호 붙이면 될까? 아니다 컴퓨터는 0과 1만 이해할 수 있기 때문에 마이터스 부호 사용하지 않고 0과 1만으로 음수 표현

0과 1만으로 음수 표현하는 방법 중가장 널리 사용되는 방법은 **2의 보수(two’scomplement)**를 수해 이 값을 음수 간주하는 방법. 2의 보수의 사전적 의미는 ‘어떤 수를 그 보다 큰 2(n)에서 뺀 값’을 의미.  
e.g. 11(2) 2의 보수는 11(2)보다 큰 2(n),  즉 100(2)에서 11(2)을 뺀 01(2) 되는 것

2의 보수를 매우 쉽게 표현하자면 ‘모든 0과 1을 뒤집고, 거기에 1을 더한 값’ 이해하면 됨.  
e.g. 11(2)의 모든 0과 1을 뒤집으면 00(2), 거기에 을 더한 값은 01(2). 즉, 11(2)의 2의 보수 (음수 표현)는 01(2)이 되는 것.

1011(2)의 음수 구하기.  
1011(2)에서 모든 0과 1을 뒤집으면 0100(2)이고 여기에 1을 더한 값은 0101(2).  
즉, 0101(2)은 1011(2)의 음수. 정말 이 값이 1011(2)의 음수인지 확인. 어떤 수의 음수를 두 번 구하면 처음 그 수가 된다. -(-A)=A. 2의 보수도 마찬가지. 어떤 수의 2의 보수를 두 번 구해 보면 자기 자신이 된다. 마찬가지로 1011(2)의 2의 보수를 두 번 구해 보면 자기 자신인 1011

---

모든 이진수의 0과 1을 뒤집은 수를 **1의 보수**라고 한다. 거기에 1을 더한 값을 **2의 보수**라고 한다. 컴퓨터는 이 수를 음수로 간주.

---

“-1011(2)을 표현하기 위한 음수으로서의 0101(2)과 십진수 5를 표현하기 위한 양수로서 0101(2)은 똑같이 생겼는데, 이진수만 보고 이게 음수인지 양수인지 어떻게 구분하지?”

실제 이진수만 봐서 이게 음수인지 양수인지 구분하기 어렵다.  
그래서 컴퓨터 내부에서 어떤 수를 다룰 떄는 이 수가 양수인지 음수인지를 구분하기 위해 **플래그(flag)**를 사용. 플래그는 쉽게 말해 부가 정보이다.  
컴퓨터 내부에서 어떤 값을 다룰 때 부가 정보가 필요한 경우 플래그를 사용.

---

이진수의 음수를 표현하기 위해 2의 보수를 취하는 방식은 아직까지도 가장 널리 사용되는 방식, 완벽한 방식은 아니다. 0이나 2(n) 형태의 이진수에 2의 보수를 취하면 원하는 음수값을 얻을 수 없다.

첫 번째 경우 자리 올림이 발생한 비트의 1을 버립.  
하지만 두 번재 경우와 같이2(n)의 보수를 취하면 자기 자신이 되어 버리는 문제는 본질적으로 해결하기 어렵다. 즉, n비트로는 -2(n)과 2(n)이라는 수를 동시에 표현할 수 없다.

---

# 십육진법

이진법을 이용해 0과 1만으로 모든 숫자를 표현.  
하나의 이진수는 하나의 비트로 나타낼 수 있기에 이진법을 이용하면 컴퓨터가 이해하는 숫자 정보를 직접적으로 표현.  
하지만 이진법은 0과 1만으로 모든 숫자를 표현하다 보니 숫자의 길이가 너무 길어진다는 단점이 있다. 십진수 32를 이진수를 표현하면 100000(2)과 같이 여섯 개의 자릿수가 필요한 것처럼

데이터를 표현할 때 이진 이외에 십육진법 자주 사용.  
**십육진법(hexadecimal)**은 수가 15를 넘어가는 시점에 자리 올림을 하는 숫자 표현 방식.  
십진수 10, 11, 12, 13, 14, 15를 십육진법 체계에서는 각각 A, B, C, D, E, F로 표기

십육진수는 한 글자로 열여섯 종류 (0 ~ 9, A ~ F)의 정보 표현. 이진수에 비해 더 적은 자릿수로 더 많은 정보 표현.  
십육진수도 이진수와 마찬가지로 숫자 뒤에 아래첨자 (16)를 붙이거나 숫자 앞에 0x를 붙여 구분  
전자는 주로 수학적으로 십육진수를 표기, 후자는 주로 코드상에서 십육진수를 표기할 때 사용되는 방식

---

**십육진법** 15를 넘어가는 시점에 자리 올림하여 수를 표현하는 방법

---

십육진법을 사용되는 주된 이유 이진수를 십육진수, 십육진수를 이진수로 변환하기 쉽기 때문

## 십육진수를 이진수로 변환하기

십육진수는 한 글자당 열여섯 종류(0 ~ 9, A ~ F)의 숫자 표현.  
그렇다면 십육진수 이루는 숫자 하나를 이진수를 표현하려면 몇 비트 필요할까? 4비트 필요 2(4) = 16

십육진수를 이진수로 변환하는 간편한 방법 중 하나는 십육진수 한 글자를 4비트의 이진수로 간주하는 거다. 즉, 십육진수를 이루고 있는 각 글자를 따로따로(4개의 숫자로 구성) 이진수로 변환진수가 있을 때 각 숫자 1(16), A(16), 2(16), B(16)를 이진수 표현 0001(2), 1010(2), 0010(2), 1011(2).  
숫자를 그대로 이어 붙인 값, 즉 0001101000101011(2)이 1A2B(2)를 이진수로 표현한 값.

## 이진수를 십육진수로 변환하기

반대로 이ㅏ진수를 십육진수로 변환할 때 이진수 숫자를 네 개씩 끊고, 끊어 준 네 개의 숫자를 하나의 십육진수로 변환한 뒤 그대로 이어 붙이면 된다.   
e.g. 11010101(2) 이진수를 네개씩 끊으면 1101(2), 0101(2)이고 이는 각각 D(16)와 5(16)이므로 이를 그대로 이어 붙인 D5(16)가 11010101(2) 십육진수로 변환하는 수

이진수를 십진수로 변환할 떄는 이렇게 간단하지 않기에 이진수를 십육진수로 묶어 표현.

---

십육진수는 프로그래밍할 때 이진수와 더불어 자주 사용되므로 기억해 두는 것이 좋다.  
 HW와 밀집하게 맞닿아 있는 개발 분야에서는 같이 코드에 십육진수를 직접 쓰는 경우도 더러 있다

```python
offset = __mem_to_opcode_arm(*(u32 *)loc);
offset = (offset & 0x00ffffff) << 2;
if (offset & 0x02000000)
offset -= 0x04000000;
offset += sym->st_value - loc;
```

프로그래밍할 때 십육진수를 직접 써넣는 경우도 많다는 사실만 인지.

# 정리

- **비트** 0과 1로 표현할 수 있는 가장 작은 정보 단위.
- **바이트,** 킬로바이트, 메가바이트, 기가바이트, 테라바이트는 비트보다 더 큰 정보 단위.
- **이진법**은 1을 넘어가는 시점에 자리 올림을 하여 0과 1만으로 수를 표현하는 방법.
- 이진법에서 음수는 **2의 보수**로 표현.
- **십육진법**은 15를 넘어가는 시점에 자리 올림하여 수를 표현.