# 지수 시간

최악의 시간 복잡도로 꼽히는 것은 **지수 시간 복잡도(Exponential Time Complexity)**.  
**지수 시간**으로 실행되는 알고리즘의 복잡도는 데잍 크기의 지수식으로 표현된다, 어떤 상수 c를 n 제곱한 만큼 실행 단계가 커지는 알고리즘으로, 빅 O 표기법에서는 0(c**n)으로 표기한다. 여기서 상수 c가 얼마나 큰지는 중요하지 않는다. 문제는 지수인 n.

다행히 지수 시간 복잡도가 자주 마주치는 문제는 아니다.  
e.g. n개의 숫자로 이루어진 비밀번호를 가능한 모든 조합을 시도해 알아내려고 하는 경우 지수 시간 복잡도에 해당하며, 0(10**n)으로 표기한다.

```python
pin = 931
n = len(pin)
for i in range(10**n):
     if i == pin:
         print(i)
```

알고리즘을 완료하기 위해 필요한 단계는 n이 커짐에 따라 믿을 수 없을 정도로 빠르게 커진다. n이 1이면 10번의 단계를 거쳐야 하고 n이 2이면 100번, n이 3이면, 1,000번의 단계가 필요하다. 언뜻 보기에는 지수 시간 알고리즘이 그렇게까지 빨리 커지는 것처럼 보이지않지만 감당할 수 없이 커지는 것은 순식간이다.  
여덟 자리의 비밀ㄹ번호를 알아내려면 1억번 시도해야 하고, 열 자리의 비밀번호를 알아내려면 100억 번을 시도해야 한다. 이제 비밀번호의 자릿수가 왜 그렇게 중요한지 깨달았을 것이다. 만약 네 자리의 비밀번호를 사용한다면 이런 프로그램을 토해 손쉽게 비밀번호를 알아낼 수 있다. 반면 스무 자리의 비밀 번호를 사용한다면 아마 해커가 죽을 때까지도 프로그램이 끝나지 않기 때문에 절대 알아낼 수 없을 것이다.

이런 식으로 비밀번호를 알아내는 것을 **무차별 대입 알고리즘(Brute-Force Algorithm)** 이라고 한다. 무차별 대입 알고리즘은 가능한 경우의 수를 전부 대입해 보는 알고리즘.  
보통 이 알고리즘은 비효율적이므로 최후의 수단으로만 사용한다.