# 3차 시간

**3차 시간(Cubic Time)** 으로 실행되는 알고리즘의 시간 복잡도는 n의 세제곱에 정비례하며, 0(n**3)으로 표기

3차 시간 복잡도를 따르는 알고리즘의 예제

```python
nubmers = [1, 2, 3, 4, 5]
for i in numbers:
    for j in numers:
        for h in numbers:
            x = i + j + h
            print(x)
```

이 알고리즘 f(n)

```python
f(n) -= 1 + n * n * n * (1 + 1)
```

단순화

```python
f(n) = 1 + 2 * n**3
```

2차 시간 복잡도와 마찬가지로 f(n)에서 가장 중요한 부분은 n**3이다.  
n**3은 너무나 급격하게 커지기 때문에 만약 f(n)의 나머지 부분에 n**2이 포함되어 있더라도 무시할 수 있을 정도 이다. 따라서 빅 O 표기법에서는

```python
0n = n**3
```

알고리즘에 0부터 n까지 실행하는 루프가 세 번 중첩되어 있다면 그 알고리즘은 3차 시간 복잡도를 따른다. 데이터 과학이나 통계와 관련된 일을 한다면 3차 시간 복잡도 문제를 자주 마주친다.

2차와 3차 시간 복잡도는 모두 다항 시간 복잡도에 속한다.  
**다항 시간 복잡도(Polynomial time Complexity)** 를 따르는 알고리즘 0(n**a)에 비례하여 커지는데, 2차 시간은 a가 2인 경우, 3차 시간은 a가 3인 경우에 해당.  
알고리즘을 설계할 때는 가급적 다항 시간 알고리즘을 피하는 편이 좋다. 이런 알고리즘은 n이 커짐에 따라 알고리즘의 실행 시간이 급격하게 늘어날 수 있기 때문이다. 하지만 가끔 피치 못하게 다항 시간 알고리즘을 사용해야 하는 경우에는 다음에 살펴볼 최악의 알고리즘과 비교했을 때 그나마 다항 시간 복잡도 괜찮은 편이라고 생각하는 것이 위안이 될 것이다.