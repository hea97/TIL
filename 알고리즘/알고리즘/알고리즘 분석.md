# 알고리즘 분석

한 가지 문제를 해결할 때 여러 가지 알고리즘을 사용할 수 있을 때가 많다.  
리스트를 정렬하는 방법이 다양한 것처럼 말이다. 여러 가지 알고리즘으로 문제를 풀 수 있따면 최선의 알고리즘은 어떻게 찾아야 할까요? 가장 단순한 것? 가장 빠른 것? 가장 짧은 것? 아니면 다른 기준이 있을까?

실행 시간은 알고리즘을 평가하는 기준 중 하나이다.  
알고리즘의 **실행 시간**은 Python 같은 프로그래밍 언어로 만든 알고리즘을 컴퓨터가 실행하는 데 걸리는 시간을 말한다.  
e.g.  1 ~ 5 숫자를 출력하는 Python 알고리즘

```python
for i in range(1, 6):
	print(i)
```

다음과 같이 Python에 내장된 **time** 모듈을 사용하여 이 알고리즘의 실행 시간을 측정할 수 있다.

```python
import time

start = time.time()
for i in range(1, 6):
	print(i)
end = time.time()
print(end - start)
```

**실행 결과**

1
2
3
4
5
0.002009868621826172

---

프로그램이 실행되면 1에서 5까지의 숫자가 출력되고, 여기에 소요된 시간도 출력된다. 0.002초가 걸렸다,

```python
import time

start = time.time()
for i in range(1, 6):
	print(i)
end = time.time()
print(end - start)
```

**실행 결과**

1
2
3
4
5
0.002660512924194336

---

프로그램을 두 번째로 실행하면 실행 시간이 달라진다.   
또 프로그램을 실행한다면 실행 시간은 또 달라질 것이다. 프로그램을 실행하는 순간 컴퓨터가 사용할 수 있는 CPU의 자원이 매번 다르고, 이 자원이 프로그램의 실행 시간에 영향을 미치므로 알고리즘의 실행 시간도 매번 달라진다.

또한 알고리즘의 실행 시간은 컴퓨터의 성능에 따라도 다르다.  
처리 능력이 떨어지는 컴퓨터에서 실행하면 그만큼 느릴 것이고, 성능이 좋은 컴퓨터에서 실행하면 그만큼 빠를 것이다. 프로그램의 실행 시간은 사용하는 프로그래밍 언어에 따라서도 달라진다.  
e.g. C언어  
C언어의 경우 Python보다 실행속도가 더 빠르기 때문에 같은 프로그램이라도 C언어로 작성하면 실행 시간이 짧아진다

알고리즘을 비교할 때 알고리즘의 실행 시간은 컴퓨터 CPU의 자원이나 프로그램이 언어와 같은 여러 가지 변수의 영향을 받으므로 효과적인 기준이 될 수 없다. 이러한 이유로 컴퓨터 과학자들은 알고리즘에 필요한 단계를 살펴보면서 알고리즘을 비교한다.  
두 개 이상의 알고리즘을 비교해야 한다면 프로그래밍 언어나 컴퓨터의 사양과 같은 변수는 제외하고, 알고리즘에 필요한 단계를 수식으로 비교한다.

예시로, 1 ~5까지 숫자를 셌던 프로그램이다

```python
for i in range(1, 6):
	print(i)
```

프로그램은 다섯 번의 루프를 실행하면서 `i`를 출력하므로 총 다섯 번의 단계를 거친다.  
이 알고리즘에 필요한 단계는 `f(n)`으로 표현할 수 있다.

```python
f(n) = 5
```

프로그램이 복잡해지면 `f(n)`도 바뀐다. 출력되는 숫자의 합을 구한다.

```python
count = 0
for i in range(1, 6):
	print(i)
	count += i
```

알고리즘은 이제 열 한 번의 단계를 거쳐야 완료된다.  `count` 변수에 0을 할당, 1부터 5까지 숫자를 다섯 번 출력. 그때마다 출력된 숫자의 합을 구하므로 1 + 5 + 5 = 11 단계가 된다.

```python
f(n) = 11
```

숫자 6을 변수 n으로 바꾼다면?

```python
count = 0
for i in range(1, n):
	print(i)
	count += i
```

f(n)은 다음과 같이 바뀐다

```python
f(n) = 1 + 2n
```

알고리즘 단계는 n 값에 의해 좌우된다.  
f(n)의 1은 첫 번째 단계인 count = 0에 해당. 그 다음 숫자를 출력하고 합을 구하는 2n만큼의 단계까 필요하다.   
e.g. n이 5라면 f(n) = 1 + 2 * 5  
컴퓨터 과학자는 알고리즘의 단계를 나타내는 f(n)의 변수 n을 **데이터 크기**라고 부른다.  
데이터의 크기가 n인 문제를 푸는 데 필요한 시간이 1 + 2n이라고 할 수 있으며, 수학적으로는 T(n) = 1 + 2n이라고 표기.

알고리즘에 필요한 단계를 항상 정확하게 셀 수 없기 때문에 알고리즘의 단계를 수식으로 표현하는 것이 아주 효과적인 방법이라고 할 수는 없다.   
e.g. 알고리즘에 조건문이 많다고 했을 때.  
그 중 어떤 부분이 실행될지 미리 알 수 없을뿐더러 다행스럽게도 정확하게 알 필요는 없다

중요한 것은 n의 변화에 따른 알고리즘 성능의 변화를 예상하는 것이다.  
데이터 세트가 작을 때는 어던 알고리즘이든 별 문제가 없지만 데이터 세트가 아주 클 때는 비효율적인 알고리즘이 곧 재앙이 될 수 있다. 반대로 가장 비효율적인 알고리즘이라 하더라도 데이터의 크기가 1이라면 전혀 문제가 없지만, 실제로 데이터의 크기가 1인 경우는 거의 없다.  
십만, 백만 또는 그 이상일 가능성이 더 크다.

알고리즘이 정확하게 몇 단계를 거치는지가 아니라, 데이터의 크기가 늘어날 때마다 알고리즘의 단계가 얼마나 늘어나느지를 대략적으로 파악하는 것이 가장 중요하다.  
n이 커지면서 f(n)의 한 부분이 급격하게 커지면 그 외에 다른 부분을 비교하는 것이 무의미하다.

```python
def print_it(n):
	# 루프 1
	for i in range(n):
		print(i)
	
	# 루프 2
	for i in range(n):
		print(i)
		for j in range(n):
			print(j)
			for h in range(n):
				print(h)
```

프로그램의 어떤 부분을 봐야 알고리즘에 몇 단계가 필요한지 판단할 수 있을까?  
루프 1과 루프 2 모두 중요한 변수라고 생각할 수 있다. 어쨌든 `n`이 10,000 정도가 된다면 컴퓨터는 두 루프 모두에서 아주 많은 숫자를 출력할 테니까요.

하지만 알고리즘의 효율성을 따질 때 루프 1은 무시해도 될 수준이다.

```python
	# 루프 1
	for i in range(n):
		print(i)
```

이해하기 위해 n이 커질 때 어떤 일이 일어나는지 살펴봐야 한다.  
이 알고리즘의 단계를 나타내는 수식 T(n).

```python
T(n) = n + n**3
```

`for` 함수가 두 번  중첩된 루프를 `n`번 반복하면,  
이는 n의 제곱인 `n**2`로 나타낸다.

e.g. `n`이 10이라면?  
n이 10이라면 10을 10번 반복해야 하므로 `10**2`가 되는 것이다. 마찬가지로 `for` 함수가 세 번 중첩된 루프는 `n**3`으로 나타낼 수 있따. 만약`T(n)`에서 `n`이 10이라면 루프 1에서는 10단계를 거치고, 루프 2에서는 10의 세제곱인 1,000단계를 거친다.  
`n`이 1,000이라면 루프 1에서는 1,000단계, 루프 2에서는 1,000의 세제곱인 10억 단계를 거치게 된다.

`n`이 커지면 커질수록 알고리즘의 두 번째 루프가 너무 빨리 커지기 때문에 첫번째 루프를 따지는 것이 무의미해진다.   
e.g. 알고리즘이 100,000,000개 데이터 대상으로 작동  
100,000,000개 데이터 대상으로 작동한다면 두 번째 루프의 단계가 너무 크기 때문에 첫 번째 루프가 몇 단계를 거치든 신경 쓰지 않게 될 것이다. 데이터가 100,000,000개라면 두 번째 루프의 단계가 1 뒤에 0이 24개나 있는 숫자가 되므로 이런 상황에서 첫 번째 루프의 단계가 100,000,000번이라는 것은 아무 의미가 없다.

따라서 알고리즘의 효율에서 가장 중요한 부분은 ‘n이 커질 때 알고리즘의 단계가 얼마만큼 증가하는가’이므로, 이것을 잘 나타내는 빅 O 표기법을 사용한다. **빅 O 표기법(Big O notation)**은 n이 커짐에 따라 알고리즘의 시간 또는 공간의 요건이 얼마나 커지는지를 나타내는 구학적 표기법을 말한다.

빅 O 표기법은 T(n)에서 규모 함수를 도출하는데, **규모(Order of Magnitude)**란 차이가 아주 큰 등급 체계에서의 크기 차이를 뜻한다.  
규모 함수에서는 알고리즘의 실행 단계를 나타내는 T(n)에서 수식을 지배하는 부분만 남기고, 나머지는 모두 무시. 즉, T(n)에서 가장 지배적인 부분이 빅 O 표기법에서 도출한 알고리즘의 규모가 되는 것이다.

빅 O 표기법에서 가장 널리 사용되는 규모 함수들을 최선(가장 효율적)에서 최악(가장 비효율적) 순서로 나열된 것이다.

상수시간 → 로그 시간 → 선형 시간 → 선형 로그 시간 → 2차 시간 → 3차 시간 → 지수 시간

각각의 규모 함수는 알고리즘의 시간 복잡도를 나타낸다.  
**시간 복잡도(Time Complexity)**란 n이 커짐에 따라 알고리즘이 실행되고 완료될 때까지 필요한 단계를 말한다.