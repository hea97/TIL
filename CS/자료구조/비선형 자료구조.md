**비선형 자료구조(non-linear data structure)**는 하나의 데이터 뒤에 N개의 데이터가 이어질 수 잇는, 1:N 또는 N:N 구조로 데이터가 나열되는 자료구조를 뜻함.  
그래서 계층적 구조를 나타내기 편리. 선형 자료구조와 달리 데이터를 하나하나 탐색하지 않아도 원하는 데이터를 찾을 수 있따는 장점 때문에 비선형 자료구조를 활용한 다양한 알고리즘이 있다.  
따라서 비선형 자료구조는 종류와 특징을 알아야 하고 주어진 문제 상황에 응용할 수 있어야 한다.

# 그래프

**그래프(graph)**는 데이터를 포함하는 **정점(vertex)**과 장점을 잇는 **간선(edge)**으로 구성된 자료구조.  
장점은 **노드(node)**라고도 한다. 일반적으로 그래프는 각 용어의 영문 앞 글자를 따라 G = (V, E)로 표현

- **인접(adjacent)**  
두 정점이 간선으로 연결되어 있으며 인접하다고 한다
- **차수(degree)**  
정점에 연결된 간선의 수를 나타냄. 그림에서 정점 B의 차수는 3이다.
- **진입 차수(in-degree)**  
해당 정점으로 향하는 간선의 수를 의미. 장점 B의 진입 차수는 1이다
- **진출 차수(out-degree)**  
해당 정점에서 나가는 간선의 수를 의미. 장점 B의 진출 차수는 2이다
- **경로(path)**  
한 정점에서 다른 정점으로 이러지는 정점들의 리스트를 뜻한다.  
A에서 D로 가는 경로 중 하나는 {A, B, C, D}이다
- **경로 길이(path length)**  
경로를 구성하는 간선의 수다. {A, B, C, D}의 경로 길이는 3이다
- **단순 경로(simple path)**  
모두 다른 정점으로 구성된 경로를 의미. 경로 {A, B, C, D}는 단순 경로
- **사이클(cycle)**  
한 정점에서 시작해 같은 정점으로 돌아올 수 있는 경로 의미.

## 그래프의 종류

그래프는 간선의 방향성 유무에 따라 무방향 그래프와 방향 그래프로 구분.

### 무방향 그래프(undirected graph)

무방향 그래프는 간선에 방향이 없는 그래프.  
두 정점이 연결되어 있을 때 순선가 없으므로(A, B)와 (B, A)는 동일한 간선을 의미.  
정점의 개수가 n일 때 최대 간선의 개수는 `n*(n-1)/2`

### 방향 그래프(directed graph)

방향 그래프는 간선에 방향성이 있는 그래프.  
두 정점이 연결되어 있을 때 A에서 B로 향하는 간선을 <A, B>로 표기.  
따럿, <A, B>와 <B, A>는 다른 간선을 의미. 정점의 개수가 n일때 최대 간선의 개수는 `n*(n-1)` 이다.

---

**부분 그래프(sub graph)**  
기존 그래프에서 일부 정점 또는 간선을 제외한 그래프.

**가중치 그래프(weighted graph)**  
간선에 비용이나 가중치가 할당딘 그래프.

**완전 그래프(complete graph)**  
간선을 최대로 가진 그래프로, 연결 그래프(connected graph)라고도 한다.  
정점의 개수가 n일 때 무방향 그래프의 간선 수가 `n*(n-1)/2`이면 완전 그래프.

**유형 비순환 그래프(DAG, Directed Acyclic Graph)**  
방향 그래프이면서 사이클이 없는 그래프.

---

## 경로 탐색

시작 정점이 주어졋을 대 간선을 거쳐 모든 정점을 탐색하는 경로를 질문하는 그래프 탐색 문제가 코딩 테스트에 자주 출제. 이 때 그래프 탐색에 사용되는 방법은 BFS와 DFS가 있음.

### 너비 우선 탐색(BFS, Breadth-First Search)

**탐색을 시작하는 정점에서 가까운 정점을 먼저 탐색하는 방식**.  
먼저 발견한 정점과 인접한 정점들을 탐색하면서 큐에 삽입. 이럴 경우 이전에 방문한 정점을 큐에 삽입하면 끊임없이 탐색을 반복하게 될 수 있다. 따라서 탐색한 정점을 큐에 넣기 전에 이전에 방문 했는지 반드시 확인.

---

**너비 우선 탐색으로 점정 A에서의 최단 거리 측정**

1. 정점 A에서 탐색을 시작. 큐에 A를 삽입
2. 큐에서 다큐를 수행하면 정점 A가 나옴. A에서 탐색 가능한 정점은 B와 C이다.  
B와 C 모두 방문한적이 없으므로 큐에 B와 C를 삽입
3. 큐에서 디큐를 수행하면 정점 B가 나옴. B에서 탐색 가능한 정점은 A, D, E이다.  
A는 이미 방문햇으므로 탐색 가능한 정점은 D와 E이다. 큐에 D와 E를 삽입
4. 큐에서 디큐를 수행하면 정점 C가 나온다. C에서 탐색 가능한 정점은 A, D, F이다 A와 D는 이미 방문햇으므로 탐색 가능한 정점은 F이다. F를 삽입.
5. 큐에서 디큐를 수행하면 정점 D가 나온다. D와 연결된 정점 B, C, E, F를 모두 방문했으므로 큐에 삽입되는 정점은 없다.
6. 큐에서 디큐를 수행하면 정점 E가 나온다. E와 연결된 정점은 B, D, F를 모두 방문햇으므로 큐에 삽입되는 정점은 없다.
7. 큐에서 디큐를 수해하면 정점 F가 나온다. F와연결된 정점으 C, D, E 중 방문한 정점이 없다. 큐가 비었으므로 탐색을 종료.

너비 우선 탐색을 하면 비가중치 그래프에서 시작 정점부터 특정 정점까지의 최단 거리를 알 수 있다.

정점 A에서 방문 가능한 정점은 B와 C로 최단 거리는 1이다.  
그렇다면 정점 B와 C에서 방문 가능한 정점까지의 거리는 (정점 A에서 B 또는 C까지의 거리) + 1임을 알 수 있다. 따라서 B에서 탐색한 D, E까지의 거리는 2(1 + 1)가 된다. C에서 탐색한 F가지의 거리 또한 (A에서 C까지의 거리) + (C에서 F까지의 거리) = 2

---

### 깊이 우선 탐색(DFS, Depth-First Search)

깊이 우선 탐색은 **시작 정점에서 탐색 가능한 최대 깊이의 정점까지 탐색**.  
만약 최대 깊이인 정점에 도달했다면 방문한 정점들을 역순으로 재방문하면서 탐색 가능한 정점이 있는지 확인. 탐색 가능한 정점이 있다면 해당 정점부터 다시 최대 깊이 정점까지 탐색을 진행.  
깊이 우선 탐색은 **재귀 호출 또는 스택으로 구현**

그래프에서 깊이 우선 탐색이 진행되는 과정 방문하는 정점들을 스택에 저장하고 최대 깊이까지 탐색을 완료했을 때 스택에 있는 정점을 하나씩 꺼내며 추가로 방문 가능한 정점 있는지 확인. 

---

**깊이 우선 탐색 과정 - 최대 깊이 정점 탐색**

1. 정점 A에는 탐색을 시작. 스택에 정점 A를 삽입
2. 정점 A에서 탐색 가능한 정점 B, C 중 B를 방문. 스택에 정점 B를 삽입.
3. 정점 B에서 탐색 가능한 정점 D, E 중 D를 방문. 스택에 정점 D를 삽입.
4. 정점 D에서 탐색 가능한 정점 C, F 중 C를 방문. 스택에 정점 C를 삽입.
5. 정점 C에서 탐색 가능한 정점 F를 방문. 스택에 정점 F를 삽입
6. 정점 F에서 탐색 가능한 정점 E를 방문. 스택에 정점 E를 삽입

정점 E에서 더 이상 탐색 가능한 정전이 없으므로 탐색 가능한 최대 깊이에 도달했다고 할 수 있다.  
따라서 스택에 있는 정점들을 역순으로 방문하여 탐색 가능한 정점이 있는지 확인.

---

---

**깊이 우선 탐색 과정 - 역순으로 방문하며 탐색**

1. 스택에서 pop을 하면 정점 E가 나옴. E에서 탐색 가능한 정점은 더 이상 존재하지 않음.
2. 스택에서 pop을 하면 정점 F가 나옴. F에서 탐색 가능한 정점은 더 이상 존재하지 않음.
3. 스택에서 pop을 하면 정점 C가 나옴. C에서 탐색 가능한 정점은 더 이상 존재하지 않음.
4. 스택에서 pop을 하면 정점 D가 나옴. D에서 탐색 가능한 정점은 더 이상 존재하지 않음.
5. 스택에서 pop을 하면 정점 B가 나옴. B에서 탐색 가능한 정점은 더 이상 존재하지 않음.
6. 스택에서 pop을 하면 정점 A가 나옴. A에서 탐색 가능한 정점은 더 이상 존재하지 않음.

스택에 탐색할 정점이 남아 있지 않으므로 깊이 우선 탐색을 종료.   
만약 pop을 한 정점을 탐색 가능한 정점이 있다면 정점을 다시 스택에 push하면서 탐색을 수행.

깊이 우선 탐색을 하면 특정 정점에서 다른 정점까지의 경로를 알 수 있다. 
이때 깊이 우선 탐색을 스택이 아닌 재귀 호출로 구현하면 방문해야 할 정점을 저장할 필요가 없어서 너비 우선 탐색 대비 저장 공간을 적게 사용.

---

# 트리

**트리(tree)**는 **그래프의 한 종류로 사이클이 없어서 계층적 관계를 표현**.

- **루드 노드(root node)**  
부모 노드가 없는 노드, 트리에는 하나의 루트 노드가 존재.
- **부모 노드(parent node)**  
루트 노드 방향으로 연결된 노드.
- **자식 노드(child node)**  
루트 노드의 반대 방향으로 연결된 노드
- **단말 노드(leaf node)**  
자식 노드가 없는 노드.
- **형제 노드(sibing node)**  
부모 노드가 같은 노드다
- **레벨(level)**  
루트 노드로부터 노드의 상대적 위치를 의미.  
일반적으로 루트 노듸의 레벨은 0이다.
- **높이(height)**  
트리의 최대 레벨 +1 의미
- **차수(degree)**  
자식 노드의 개수를 나타냄

트리에는 트리가 시작되는 루트 노드가 있다.  
그래서 루트 노드에서 자식 노드로의 방향성과 계층이 존재

## 이진 트리

**이진 트리(binary tree)**는  **자식 노드가 최대 2개인 트리**.  
대표적인 이진 트리의 종류.

### 완전 이진 트리(complete binary tree)

트리의 마지막 레벨을 제외한 모든 레벨에 노드가 채워져 있으며, 마지막 레벨은 왼쪽에서부터 오른쪽으로 노드가 채워져 있는 이진 트리

### 포화 이진 트리(perfect binary tree)

트리의 **마지막 레벨까지 노드가 모두 채워져 있는 이진 트리.**  
따라서 포화 이진 트리는 와전 이진 트리

### 이진 탐색 트리(BST, Binary Search Tree)

한 노드의 **왼쪽 서브 트리는 해당 노드의 값보다 작은 값을 가진 노드로 구성, 오른쪽 서브 트리는 해당 노드의 값보다 큰 값.** 가진 노드로 구성된 트리

균형 잡힌 이진 탐색 트리에서는 루트 노드와 가까운 노드일수록 검색해야 하는 노드 개수가 절반으로 줄어든다. 따라서 값을 검색하는 데 O(log n )이 소요. (n은 노드 개수).  
하지만 균형이 잡히지 않은 이진 탐색 트리에서는 검색하는 데 시간 복잡도 O(n)이 소요되므로 이진 탐색 트리를 이용하는 장점 사라짐

그래서 완전 이진 트리로 이진 탐색 트리를 구성하려면 **균형 이진 탐색 트리(balanced BST)**가 필요 하다. 균형 이진 탐색 트리 대표적인 예로는 레드-블랙 트리와 AVL 트리

---

이진 탐색 트리에서 데이터의 추가, 삭제 방식

### 데이터 추가

이진 탐색 트리에서 데이터 추가는 루트 노드부터 차례대로 비교해 나가면서 삽입할 자리를 찾는 방식.  
추가하려는 데이터가 비교하는 노드보다 값이 큰 경우는 오른쪽 자식 노드와 비교를 수행, 작은 경우는 왼쪽 자식 노드와 비교를 수행. 다음과 같은 이진 탐색 트리에 노드 13을 추가하는 과정.

1. 추가하려는 데이터 13은 루트노드의 데이터인 15보다 작다.  
따라서 다음 비교는 루트 노드의 왼쪽 자식 노드와 수행
2. 추가하려는 데이터 13은 왼쪽 자식 노드인 10보다 크다.  
따라서 다음 비교는 해당 노드의 오른쪽 자식 노드와 수행.
3. 오른쪽 자식 노드이 자리가 비었으므로 13을 해당 자리에 추가

### 데이터 삭제

이진 탐색 트리에서 데이터를 삭제하는 경우는 자식 노드의 개수에 따라 3가지로 나눌 수 있다.

- **자식 노드가 없는 경우**  
**해당 노드만 삭제**. 다음 이진 탐색 트리에서 데이터 17을 삭제한다고 했을 때 데이터 17을 가진 노드는 자식 노드가 없으므로 해당 노드만 삭제하면 연산이 끝.
- **자식 노드가 1개인 경우**  
자식 노드를 삭제한 노드의 위치로 옮김.  
다음 이진 탐색 트리에서 데이터 10을 삭제한다고 했을 때 데이터 10을 가진 노드는 데이터 5를 가진 자식 노드가 있다. 따라서, 10을 가진 노드 자리에 5를 가진 노드를 위치시키면 된다.
- **자식 노드가 2개인 경우**  
오른쪽 서브 트리에서 가장 작은 값을 삭제한 노드 위치로 옮기면 됨.  
또는 왼쪽 서브 트리에서 가장 큰 값을 삭제한 노드 위치로 옮겨도 된다. 다음 이진 탐색 트리에서 데이터 15를 삭제한다고 했을 때 데이터 15를 가진 노드는 자식 노드가 2개 있다. 이때 오른쪽 서브 트리에서 가장 작은 값을 찾아 데이터 15를가 있던 자리에 넣는다. 오른쪽 서브 트리에서 가장 작은 값은 17이므로 17을 가진 노드를 15강 있던 자리에 위치시키면 된다.

---

균형 이진 탐색 트리는 삽이비나 삭제 연산을 수행해도 트리의 균형을 유지하는 트리를 읨.  
이진 탐색 트리가 불균형인 경우 시간 복잡도에서 이점을 볼 수 없다는 단점 보완한 트리.  
대표적인 예로 레드-블랙트리와 AVL 트리.

### 레드-블랙 트리

레드-블랙 트리(red-black tree)는 노드가 검은색 또는 빨간색인 트리로, 정해진 규칙을 만족하면서 균형을 유지하는 트리

레드 블랙 트리는 이진 탐색 이면서 추가로 충족해야 하는 조건이 있다.  
트리의 데이터에 대한 연산을 수행했을 때 다음 조건을 만족하지 못하면 회전과색 변환을 해서 노드를 재배치.

- 모든 노드는 검은색 또는 빨간색
- 루트 노드는 검은색.
- 모든 단말 노드(NIL)는 검은색. 단말 노드는 트리의 끝을 나타내며 값을 갖지 않는다.
- 빨간색 노드의 자식 노드는 검은색이며 빨간색 노드가 연속적으로 나올 수 없다.
- 루트 노드에서 임의의 단말 노드까지 경로에 검은색 노드의 개수는 모두 같다

### AVL 트리

AVL 트리는 자가 균형 이진 탐색 트리, 왼쪽 서브 트리와 오른쪽 서브 트리의 높이 차이를 유지해 균형을 잡는 트리. 높이 차이를 알려면 왼쪽 서브 트리의 높이에서 오른쪽 서브 트리의 높이를 뺀 값은 BF(Balance Factor)를 사용

- 왼쪽 서브 트리와 오른쪽 서브 트리의 높이 차이는 최대 1.
- 왼쪽 서브 트리와 오른쪽 서브 트리의 높이 차이가 1보다 커지면 균형을 잡아 높이 차이를 줄임.

AVL 트리에는 LL, RR, LR, RL이라는 4가지 불균형 상황.  
불균형 상황이면 트리를 회전해 균형을 유지. 오른쪽 회전은 해당 노드를 중심으로 시계 방향 회전, 왼쪽 회전은 해당 노드를 중심으로 반시계 방향 회전을 의미.

### LL(Left Left) 불균형

왼쪽으로 불균형을 이룰 경우에 가운데 노드를 중심으로 오른쪽으로 회전해서 균형을 맞춤

### RR(Rlight Right) 불균형

오른쪽으로 불균형을 이룰 경우에 가운데 노드를 중심으로 왼쪽으로 횐전해서 균형을 맞춤

### LR(Left Right) 불균형

왼쪽, 오른쪽으로 불균형을 이룰 경우에 마지막 레벨에 위치한 노드를 중심으로 왼쪽으로 회전한 후 다시 오른쪽으로 회전해서 균형을 맞춤

### RL(Right Left) 불균형

오른쪽, 왼쪽으로 불균형을 이룰 경우 마지막 레벨에 위치한 노드를 중심으로 오른쪽으로 회전한 후 왼쪽으로 회전해서 균형을 맞춤

# 우선순위 큐

**우선순위 큐(priority queue)**는 **우선순위가 높은 데이터가 먼저 나오는 자료구조**.  
큐와 동일하게 데이터 삽입과 삭제 연산을 지원. 데이터 삭제 연산을 수행하면 우선순위가 가장 높은 데이터를 얻을 수 있다.

우선순위 큐를 구현하는 방식은 배열, 연결 리스트, 완전 이진 트리인 힘이 있다.  
각 구현 방식의 시간 복잡도는 일반적으로 가장 효율적인 방식인 힙을 사용.

| 구현 방법 | 삽입 | 삭제 |
| --- | --- | --- |
| 배열(unsorted array) | O(1) | O(n) |
| 연결 리스트(unsorted linked list) | O(1) | O(n) |
| 배열(sorted array) | O(n) | O(1) |
| 연결 리스트(sorted linked list) | O(n) | O(1) |
| 힙(heap) | O(log n) | O(log n) |

# 힙

**힙(heap)**은 **완전 이진 트리로, 최댓값 또는 최솟값을 빠르게 찾을 수 있는 자료구조.**  
우선 순위 큐를 구현하는 데 자주 사용.

- **최대 힙(max heap)**  
부모 노드의 값이 자식 노드의 값보다 크거나 같은 완전 이진 트리.
- **최소 힙(min heap)**  
부모 노드의 값이 자식 노드의 값보다 작거나 같은 완전 이진 트리.

힙에서 데이터 삽입과 삭제 연산 방법

### 삽입 연산

힙에 데이터를 삽입할 때는 힙의 맨 끝에서 이루어진다.  
부모 노드와 우선순위(최댓값 또는 최솟값)를 비교해 부모 노드보다 우선순위가 높으면 위치를 바꾸면서 루트 노드까지 비교

1. 최대 힙의 맨 끝에 데이터 30을 가진 노드를 추가
2. 최대 힙이므로 부모 노드의 값이 30보다 작으면 새로 추가한 노드와 위치를 바꿔야 한다. 새로 추가한 노드의 부모 노드 값은 19이므로 새로 추가한 노드의 우선순위가 높다. 따라서 자리를 바꾼다.
3. 데이터 30을 가진 노드와 부모 노드의 값을 비교.  
부모 노드의 값인 25보다 크므로 자리를 바꾼다
4. 데이터 30을 가진 노드가 루트 노드가 되어 비교 가능한 노드가 없으므로 연산 종료.

### 삭제 연산

힙에서 데이터 삭제는 우선순위가 가장 높은 노드를 삭제하는 연산.  
즉, 루트 노드를 삭제하게 된다. 삭제한 후 루트 노드 자리에 힙의 마지막 노드(마지막 레벨의 가장 오른쪽 노드)를 옮긴 후 힙을 재정렬

1. 루트 노드를 삭제. 힙의 마지막 노드(2)를 루트 노드 자리로 옮김
2. 새로운 루트 노드(2)와 자식 노드 2개(10, 19) 중에서 우선순위가 높은 자식 노드의 값(19)을 비교한다. 자식 노드의 우선순위가 높으므로 위치를 바꾼다
3. 바뀐 위치에서 자식 노드와 값을 비교. 자식 노드의 값(17)보다 우선순위가 낮으므로 위치를 바꾼다.
4. 비교할 수 있는 자식 노드가 없으므로 연산을 종료

# 해시 테이블

**해시 테이블(hash table)**은 **하나의 키(key)에 대해 하나의 값(value)을 저장하는 형태의 자료 구조**.  
키는 **해시 함수(hash fiunction)**를 사용해 해시를 얻을 수 있다. **해시**는 값이 저장되어 있는 해시 테이블의 인덱스를 찾을 수 있는 값. 해시 함수에 키를 넣으면 해시 테이블에서 매칭되는 겨로가 값에 한 번에 접근할 수 있다. 따라서 연산은 평균적으로 **O(1)** 시간 복잡도.

예를 들어, 해시 테이블이 있을 때 아메리카노를 해시 함수에 넣으면 2라는 해시를 얻는다.  
해시는 인덱스를 의미하므로 해시 테이블의 인덱스 2에 저장된 4000우너이라는 결과 값을 얻을 수 있다.

하지만 해시 테이블에는 해시충돌이라는 단점.  
**해시 충돌**은 서로 다른 키에 대해 같은 해시가 도출되는 것을 말함. 해시 충돌 문제를 해결하기 위한 방법에는 채이닝과 개방 주소법

### 채이닝(chaining)

해시 충돌이 발생하면 **같은 해시가 나오는 키의 값을 연결 리스트에 저장하는 방식**.  
연결 리스트에 노드를 저장하므로 저장 공간에 대한 제약이 적다는 장점. 하지만 하나의 해시(인덱스)에 노드가 몰릴 수 있다는 단점.

### 개방 주소법(open addressing)

해시 충돌이 발생했으 ㄹ때 해당 해시가 아닌 **비어 있는 공간에 값을 저장하는 방식**.  
개방 주소법에는 선형 조사법, 이차 조사법, 이중 해싱

- **선형 조사법(linear probing)**  
h[n]에서 해시 충돌이 발생하면 h[n+1], h[n+2]와 같이 다음 인덱스로 이동하면서 빈 공간을 찾는 방식.  
선형 조사법은 충돌이 발생하면 다음 인덱스에 데이터를 저장하므로 특정 인덱스 범위에 데이터가 몰리는 군집화 현상이 나타나는 단점.
- **이차 조사법(quadratic probing)**  
이차는 거듭제곱을 의미.  
h[n]에서 해시 충돌이 발생하면 h[n+1*1], h[n+2*2], h[n+3*3]과 같이 거듭제곱한 인덱스만큼 이동 빈 공간을 찾으면 데이터를 저장하는 방식. 이차 조사법은 선형 조사법보다 군집화 현상이 적지만, 완전히 해결한다고 할 수 없다
- **이중 해싱(double hashing)**  
해시 충돌이 발생하면 다른 해시 함수를 한 번 더 적용하는 방법