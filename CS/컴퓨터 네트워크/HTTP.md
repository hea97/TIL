# HTTP

**HTTP(HyperText Transfer Protocol)** 는 인터넷상에서 데이터를 전송하기 위한 프로토콜로, TCP/IP 4계층에서 응용 계층에 속한다. 

**HTTP의 특징**

## 비연결성(connectionless)

**클라이언트에서 요청을 보낸 후 서버로부터 응답을 받으려면 연결을 끊는 것** 을 의미.  
비연결성은 불특정 다수를 대상으로 하는 서비스에 유리, 서버에서 응답을 받고 나서도 연결을 유지하려면 그만큼 자원을 사용. 따라서 비연결성은 연결을 유지하지 않음으로써 자원을 아낄 수 있다.

하지만 연결을 유지하기 않기 때문에 서버가 클라이언트를 기억할 수 없다는 단점이 있다. 또한, 동일한 클라이언트에서 연속적으로 요청이 오면 연결과 연결 해제 과정을 반복하게 되어 자원을 낭비하게 된다.

이러한 단점을 보완하기 위해 일정 시간 동안 연결을 유지할 수 있도록 **HTTP Keep Alive** 를 사용. 따라서 마지막 응답 이후 일정 시간 동안 연결을 유지해 동일한 클라이언트로부터 요청이 오면 연결 과정을 생략할 수 있다.

---

**HTTP keep Alive**  
HTTP 연결 시 일정 시간 동안 요청을 유지할 수 있도록 사용하는 HTTP 헤더의 일종. 클라이언트에서 HTTP 요청을 보낼 때 연결 헤더에 Keep Alive 추가하면서 보내면 서버에서 연결을 유지할 시간을 Keep Alive 헤더에 추가해 응답.

---

## 무상태(stateless)

**서버에서 클라이언트의 상태를 저장하지 않는 것** 의미.  
예를 들어, 카페에서 음료를 주문할 때 직원이 주문 내용(이전 상태)을 기억하지 못하는 상황을 가정할 수 있다.

---

상황A

고객 : 아이스 아메리카노 한 잔 주세요.

직원 : 5천원 입니다. 결제 어떻게 하시겠어요?

고객 : 카드로 할게요

직원 : 어떤 음료 주문하시나요?

---

하나의 질문-답변이 끝났을 때 이전 내용을 기억하지 못하면 고객은 요청 내용을 모두 정리해 한 번에 ‘아이스 아메리카노 한 잔을 카드로 결제할게요’라고 말해야 한다.

이처럼 무상태는 클라이언트가 이전에 요청한 사항을 서버에 저장하지 않는다. 따라서 클라이언트는 요청에 필요한 데이터를 모두 가지고 있어야 한다. 또는 서버가 클라이언트로부터 받은 요청 사항을 모두 저장해야 한다. 이 방법들을 각각 **쿠키(cookie)** 와 **새션(session)** 이라고 한다.

무상태의 장점은 서버 확장성이 높다는 점.  
클라이언트의 요청에 응답하는 서버가 바뀌어도 되기 때문에 서버를 계속 확장해도 된다.  
따라서 특정 서버에 문제가 생겨 응답하지 못하는 문제점을 보완할 수 있다.

---

**쿠키(cookie)**  
클라이언트의 로컬 웹 브라우저에 저장하는 데이터 파일로, 키와 값을 저장.  
쿠키의 대표적인 예로는 웹 사이트의 로그인 정보와 온라인 쇼핑몰의 장바구니가 있다.

**세션(session)**  
서버에서 클라이언트와의 연결 정보를 저장 및 관리하는 것을 말함.  
서버에 데이터가 저장되므로 보안 면에서 쿠키보다 좋지만, 접속자가 많을 경우 서버에 과부하가 올 수 있다.

---

HTTP에서는 클라이언트와 서버가 통신하기 위해 정형화된 데이터인 **HTTP 메시지** 를 주고 받는다.  

- **요청 라인(request line)**  
요청 URL, 요청 방법, HTTP 버전 등을 포함.
- **상태 라인(status line)**  
요청에 대한 HTTP 상태 코드와 HTTP 버전을 포함
- **헤더(header)**  
키-값으로 구성된 다수의 헤더 항목으로 구성.
- **빈 줄(blank line)**  
헤더의 끝을 나타내는 빈 줄로, 헤더와 바디를 구분.
- **바디(body)**  
요청할 때 요청 방법 메서드가 POST인 경우메나 바디가 있고, 그 외 메서드일 때는 비어 있는 상태로 전달.

---

HTTP 상태 코드는 클라이언트의 요청에 대한 서버의 상태를 알려 주는 코드, 세 자리 숫자로 표현한다. 코드의 시작 숫자로 의미를 알 수 있다.

- **1XX**  
클라이언트로부터 요청을 받아 처리 중
- **2XX**  
요청을 성공적으로 처리함
- **3XX**  
요청을 처리하기 위해 추가 처리 필요
- **4XX**  
클라이언트 오류
- **5XX**  
서버 오류

**자주 나오는 HTTP 상태 코드.**

| 상태 코드 | 의미 | 분류 |
| --- | --- | --- |
| 200 | 클라이언트 요청을 성공적으로 처리함 | 요청 성공 |
| 401 | 인증되지 않음 | 클라이언트 오류 |
| 403 | 접근 실패 |  |
| 404 | 클라이언트에서 요청한 자원을 찾지 못함 |  |
| 500 | 서버 내부 오류 발생 | 서버 오류 |

**세부적으로…**

### 1XX : Informational(정보 제공)

| 상태 코드 | 상태 텍스트 | 한국어 뜻 | 의미 |
| --- | --- | --- | --- |
| 1XX | Informational | 정보 제공 | **클라이언트의 요청을 받았으며 작업을 계속 진행하고 있다.** 1xx 계열의 응답은 HTTP/1.1 클라이언트에게만 보낼 수 있으며 응답은 바디 없이 상태 라인, 헤더(생략 가능), 빈 줄로 종료됩니다 |
| 100 | Continue | 계속 | **계속 진행하라.** 클라이언트는 요청 헤더에 ‘Expect: 100-continue’를 보내고 서버는 이를 처리할 수 있으며 이 코드로 응답합니다 |
| 101 | Switching Protocols | 프로토콜 전환 | **프로토콜을 전환하라.** 프로토콜을 HTTP 1.1 업그레이드할 때 Upgrade 응답 헤더에 표시합니다. 현재는 HTTP 1.1 최신이므로 사용할 일이 없습니다 |
| 102 | Processing | 처리중 | **(WebDAV) 처리 중이다** 서버가 처리하는 데 오랜 시간이 예상되어 클라이언트에서 타임 아웃이 발생하지 않도록 이 응답 코드를 보냅니다 |
| 103 ~ 199 | Unassigned |  | 현재 할당되지 않은 상태 코드. |

### 2XX : Success(성공)

| 상태 코드 | 상태 텍스트 | 한국어 뜻 | 의미 |
| --- | --- | --- | --- |
| 2XX | Success | 성공 | **클라이언트가 요청한 동작을 수신하여 이해하였고 승낙하였으며 성공적으로 처리.** |
| 200 | OK | 성공 | 서버가 요청을 성공적으로 처리. |
| 201 | Created | 생성됨 | **요청이 처리되어서 새로운 리소스가 생성.** 응답 헤더 Location에 새로운 리소스의 절대 URL를 기록. |
| 202 | Accepted | 허용됨 | **요청은 접수, 처리가 완료되지 않음.** 응답 헤더의 Location, Retry-After를 참고하여 클라이언트는 다시 요청을 보냄 |
| 203 | Non-Authoritative Information | 신뢰할 수 없는 정보 | **응답 헤더가 오리지널 서버로부터 제공된 것이 아님.** 프록시 서버가 응답 헤더에 주석을 덧붙인 경우가 하나의 예 |
| 204 | No Content | 콘텐츠 없음 | **처리 성공, 클라이언트에게 돌려줄 콘텐츠 없음.** 응답에는 헤더만 있고 바디는 없음. DELETE 요청 대한 응답에 많이 사용 |
| 205 | Reset Content | 콘텐츠 재설정 | **처리 성공, 브라우저의 화면을 리셋.** 예를 들어 브라우저가 입력 폼을 보여 주고 있을 때 이 응답 코드를 받으면 브라우저는 모든 입력 항목을 리셋하고 재입력할 수 있는 상태 |
| 206 | Partial Content | 일부 콘텐츠 | **콘텐츠의 일부만을 보냄.** 응답 헤더의 Content-Range에 응답 콘텐츠 범위를 기록. 예를 들어 1,500 바이트의 리소스 중에서 처음의 500바이트만을 보낼 때 사용할 수 있다. |
| 207 | Multi-Status | 다중 상태 | **(WebDAV) 처리 결과 스테이터스가 여러개.** 207응답은 성공 뜻, 각각의 처리 결과가 성공인지는 바디를 봐야 알 수 있음 |
| 208 ~ 299 | Unassigned |  | 현재 할당되지 않은 상태 코드 |

### 3XX : Redirection(리다이렉션)

| 상태 코드 | 상태 텍스트 | 한국어 뜻 | 의미 |
| --- | --- | --- | --- |
| 3XX | Redirection | 리다이렉션 | **클라이언트는 요청을 마치기 위해 추가 동작을 취해야한다.** |
| 300 | Multiple Choies | 여러 선택 항목 | **선택 항목이 여러 개 있다.** 지정한 URL에 대해서 콘텐츠 협상을 수행한 결과 서버에서 콘텐츠를 결정하지 못하고 클라이언트에게 복수 개의 링크를 응답할 때 사용 |
| 301  | Moved Permanectly | 영구 이동 | **지정한 리소스가 새로운 URL로 이동**. 이동할 곳의 새로운 URL는 응답 헤더 Location에 기록 |
| 302 | Found | 다른 위치 찾음 | **요청한 리소스를 다른 URL에서 찾음.** 요청한 URL가 없으므로 클라이언트 메소드를 그대로 유지한 채 응답 헤더 Location에 표시된 다른 URL로 요청을 재송신할 필요가 있음. 307을 정의하였으므로 이 응답 코드의 사용은 권장하지 않음 |
| 303 | See Other | 다른 위치 보기 | **다른 위치로 요청하라.** 요청에 대한 처리 결과를 응답 헤더 Location에 표시된 URL에 GET으로 취득할 수 있음. 브라우저의 폼 요청을 POST로 처리하고 그 결과 ㅁ화면으로 리다이렉트시킬 때 자주 사용하는 응답 코드 |
| 304 | Not Modified | 수정되지 않음 | **마지막 요청 이후 요청한 페이지는 수정되지 않음** If-Modified-Since와 같은 조건부 GET 요청일 때 지정한 리소스가 갱신되지 않았음을 알려 줍니다. 이 응답 코드에는 바디가 없음 |
| 305 | Use Proxy | 프록시 사용 | 지정한 리소스에 액세스하려면 프록시를 통해야 한다.응답 헤더 Location에 프록시의 URI를 기록합니다. |
| 306 | (Unused) |   | 예전 버전에서 사용하다가 현재는 사용하지 않는 상태 코드입니다. |
| 307 | Temporary Redirect | 임시 리다이렉션 | 임시로 리다이렉션 요청이 필요하다.요청한 URI가 없으므로 클라이언트 메소드를 그대로 유지한 채 응답 헤더 Location에 표시된 다른 URI로 요청을 재송신할 필요가 있습니다. 클라이언트는 향후 요청 시 원래 위치를 계속 사용해야 합니다. 302의 의미를 정확하게 재정의해서 HTTP/1.1의 307 응답으로 추가되었습니다. |
| 308~399 | Unassigned |   | 현재 할당되지 않은 상태 코드입니다. |

### 4XX : **Client Error(클라이언트 에러)**

| 상태 코드 | 상태 텍스트 | 한국어 뜻 | 의미 |
| --- | --- | --- | --- |
| 4XX | Client Error | 클라이언트 에러 | **클라이언트의 요청에 오류가 있다.** |
| 400 | Bad Request | 잘못된 요청 | **요청의 구문이 잘못되었다.** 클라이언트가 모르는 4xx 계열 응답 코드가 반환된 경우에도 클라이언트는 400과 동일하게 처리하도록 규정하고 있습니다. |
| 401 | Unauthorized | 권한 없음 | **지정한 리소스에 대한 액세스 권한이 없다.** 응답 헤더 WWW-Authenticate에 필요한 인증 방식을 지정합니다. |
| 402 | Payment Required | 결제 필요 | **지정한 리소스를 액세스하기 위해서는 결제가 필요하다.** 이 응답 코드는 실제로는 사용되지 않습니 |
| 403 | Forbidden | 금지됨 | **지정한 리소스에 대한 액세스가 금지되었다.** 401 인증 처리 이외의 사유로 리소스에 대한 액세스가 금지되었음을 의미합니다. 리소스의 존재 자체를 은폐하고 싶은 경우는 404 응답 코드를 사용할 수 있습니다. |
| 404 | Not Found | 찾을 수 없음 | **지정한 리소스를 찾을 수 없다.** |
| 405 | Method Not Allowed | 허용되지 않은메소드 | **요청한 URI가 지정한 메소드를 지원하지 않는다.** 응답 헤더 Allow에 이 URI가 지원하는 메소드 목록을 기록합니다. |
| 406 | Not Acceptable | 수용할 수 없음 | **클라이언트가 Accept-* 헤더에 지정한 항목에 관해 처리할 수 없다.** 응답 바디에는 300 응답처럼 서버가 수용 가능한 다른 선택지 리스트가 기록됩니다. |
| 407 | Proxy AuthenticationRequired | 프록시 인증 필요 | **클라이언트는 프록시 서버에 인증이 필요하다**. 프록시 서버의 응답 헤더 Proxy-Authenticate에 필요한 인증 방식을 지정합니다. |
| 408 | Request Timeout | 요청 시간초과 | **요청을 기다리다 서버에서 타임아웃하였다.** |
| 409 | Conflict | 충돌 | **서버가 요청을 수행하는 중에 충돌이 발생하였다.** 예를 들어 사용자명을 new_name으로 변경하려 하였지만, 서버에 이미 new_name이라는 사용자가 존재하는 경우입니다. 응답 헤더 Location에는 충돌이 발생한 리소스의 URI를 기록합니다. |
| 410 | Gone | 사라짐 | **지정한 리소스가 이전에는 존재하였지만, 현재는 존재하지 않는다**. 예를 들어 기간이 한정된 프로모션 사이트가 사라진 경우 사용할 수 있는 응답 코드입니다. |
| 411 | Length Required | 길이 필요 | **요청 헤더에 Content-Length를 지정해야 한다.** |
| 412 | Precondition Failed | 사전 조건 실패 | **If-Match와 같은 조건부 요청에서 지정한 사전 조건이 서버와 맞지 않는다.** |
| 413 | Request EntityToo Large | 요청 객체가너무 큼 | **요청 메시지가 너무 크다**. 서버는 접속을 끊습니다. |
| 414 | Request-URIToo Large | 요청 URI가너무 긺 | **요청 URI가 너무 길다.** |
| 415 | UnsupportedMedia Type | 지원되지 않는미디어 유형 | **클라이언트가 지정한 미디어 타입을 서버가 지원하지 않는다**. 예를 들어 서버가 지원하는 이미지는 JPG, PNG뿐인데 클라이언트가 GIF 형식의 이미지를 요청하는 경우입니다. |
| 416 | Range Not Satisfiable | 처리할 수 없는요청 범위 | **클라이언트가 지정한 리소스의 범위가 서버의 리소스 사이즈와 맞지 않는다.** |
| 417 | Expectation Failed | 예상 실패 | **클라이언트가 지정한 Expect 헤더를 서버가 이해할 수 없다.** |
| 418 ~ 421 | Unassigned |   | 현재 할당되지 않은 상태 코드입니다. |
| 422 | Unprocessable Entity | 처리할 수 없는엔티티 | **(WebDAV) 클라이언트가 송신한 XML이 구문은 맞지만, 의미상 오류가 있다.** |
| 423 | Locked | 잠김 | (WebDAV) 지정한 리소스는 잠겨있다. |
| 424 | Failed Dependency | 의존 관계로 실패 | **(WebDAV) 다른 작업의 실패로 인해 본 요청도 실패하였다.** |
| 426 | Upgraded Required | 업그레이드필요함 | **클라이언트의 프로토콜의 업그레이드가 필요하다.** 응답에 Upgrade 헤더를 보내 필요한 프로토콜을 알려 줍니다. |
| 428 | Precondition Required | 사전 조건 필요함 | **If-Match와 같은 사전조건을 지정하는 헤더가 필요하다.** If-Match 헤더가 있지만, 맞지 않는 경우는 412 응답을 보냅니다. |
| 429 | Too Many Requests | 너무 많은 요청 | **클라이언트가 주어진 시간 동안 너무 많은 요청을 보냈다.** 요청의 속도를 제한할 때 사용합니다.  응답에 Retry-After 헤더를 보내 얼마나 기다릴지를 알려 줄 수 있습니다. |
| 431 | Request Header Fields Too Large | 너무 큰 헤더 | **헤더의 길이가 너무 크다.** 헤더의 전체 크기가 크거나 또는 하나의 헤더가 매우 큰 경우입니다. 보통 Referer URL이 길거나 쿠키 항목이 많은 경우입니다. |
| 444 | Connection Closed Without Response | 응답 없이연결 닫음 | (NGINX) 응답을 보내지 않고 연결을 종료하였다.보통 악의적인 요청에 대해서 사용하며 클라이언트에서는 응답을 볼 수 없고 Nginx 로그에는 나타납니다. |
| 451 | Unavailable For Legal Reasons | 법적 사유로 불가 | 법적으로 문제가 있는 리소스를 요청하였다. |
| 452 ~ 499 | Unassigned |   | 현재 할당되지 않은 상태 코드입니다. |

### **5XX : Server Error(서버 에러)**

| 상태 코드 | 상태 텍스트 | 한국어 뜻 | 의미 |
| --- | --- | --- | --- |
| 5XX | Server Error | 서버 에러 | **클라이언트의 요청은 유효한데 서버가 처리에 실패하였다.** |
| 500 | Internal Server Error | 내부 서버 오류 | **서버에 에러가 발생하였다.** 클라이언트가 모르는 5xx 계열의 응답 코드가 반환된 경우에도 클라이언트는 500과 동일하게 처리하도록 규정하고 있습니다. |
| 501 | Not Implemented | 구현되지 않음 | **요청한 URI의 메소드에 대해 서버가 구현하고 있지 않다.** |
| 502 | Bad Gateway | 불량 게이트웨이 | **게이트웨이 또는 프록시 역할을 하는 서버가 그 뒷단의 서버로부터 잘못된 응답을 받았다.** |
| 503 | Service Unavailable | 서비스 제공불가 | **현재 서버에서 서비스를 제공할 수 없다**. 보통은 서버의 과부하나 서비스 점검 등 일시적인 상태입니다. |
| 504 | Gateway Timeout | 게이트웨이 시간초과 | **게이트웨이 또는 프록시 역할을 하는 서버가 그 뒷단의 서버로부터 응답을 기다리다 타임아웃이 발생하였다.** |
| 505 | HTTP Version Not Supported | HTTP 버전미지원 | **클라이언트가 요청에 사용한 HTTP 버전을 서버가 지원하지 않는다.** |
| 506 | Unassigned |   | 현재 할당되지 않은 상태 코드입니다. |
| 507 | Insufficient Storage | 용량 부족 | **(WebDAV) 서버에 저장 공간 부족으로 처리에 실패하였다.** |
| 512 ~ 599 | Unassigned |   | 현재 할당되지 않은 상태 코드입니다. |

---

# HTTPS

**HTTPS(HyperText Transfer Protocol secure)**는 **보안 계층인 SSL/TLS 를 이용해 HTTP의 보안을 강화한 웹 통신 프로토콜이다.**  HTTP는 데이터 암호화를 거치지 않고 전송해서 보안에 취약.  
이를 보완한 HTTPS가 등장.

**SSL(Secure Socket Layer)** 은 넷스케이스(Netscape)에서 개발한 암호화 프로토콜이다.  
당시 SSL은 몇 가지 문제점이 있었는데, 이를 보완해 새로운 암호화 프로토콜인 **TLS(Transport Layer Security)**  를 개발. HTTPS에서 통용되는 방식은 TLS지만, SSL이라는 명칭이 사라지지 않아서 SSL또는 SSL/TLS라고 부른다.

HTTPS의 동작 방식은 다음과 같다.  
데이터를 송신할 때 응용 계층에서 보안 계층의 SSL/TLS로 데이터를 보내면 데이터를 암호화해 전송계층으로 전달. 그러면 데이터를 수신할 때 전송 계층에서 보낸 데이터를 보안 계층의 SSL/TLS에서 받아 복호화한 후 응용 계층으로 보낸다.

---

### 대칭 키 암호화 방식과 공개 키 암호화 방식

SSL/TLS에서는 암호화를 위해 2가지 암호화 방식을 사용한다.

- **대칭 키 암호화 방식**  
데이터 암호화의 복호화에 모두 같은 키인 대칭 키를 이용하는 방식.  
먼저 수신자가 가진 키를 송신자에게 준다. 이때 수신자가 같더라도 송신자가 다르면 이용하는 키도 다름. 송신자는 받은 키로 데이터를 암호화한 후 수신자에게 보낸다. 수신자는 동일한 키로 데이터를 복호화한다. 이 방식을 이용할 때는 대칭 키가 유출되지 않도록 주의해야 한다.
- **공개 키 암호화 방식**  
데이터의 암호화와 복호화를 다른 키로 하는 방식.  
데이터를 암호활 때는 공개 키를, 데이터를 복호화할 때는 비밀 킬를 송신자에게 준다. 이때 송신자가 달라도 공개 키는 같다. 송신자는 수신자에게 받은 키로 데이터를 암호화한다. 수신자는 비밀 키로 송신자에게 받은 데이터를 복호화한다. 이 방식은 비밀 키가 있어야만 데이터를 복호활 수 있어서 공개 키 유출을 염려하지 않아도 된다.

# 웹 페이지 접속 과정

지금까지 다룬 내용을 바탕으로 사용자가 URL을 입력했을 때 화면이 나타나기까지 전제 과정을 정리.

- 사용자가 URL을 웹 브라우저에 입력한다.
- 웹 브라우저는 입력한 URL을 바탕으로 DNS(Domain Name System) 서버에 연결한 IP를 요청
- DNS 서버는 IP 주소를 웹 브라우저에게 응답으로 제공
- 웹 프라우저는 DNS 서버에서 받은 IP를 통해 웹 서버와 TCP/IP 연결을 하고 HTTP 요청을 보냄
- 웹 서버는 받은 HTTP 요청에 응답. 응답은 웹 페이지와 필요한 리소스 포함
- 웹 브라우저는 받은 응답을 바탕으로 사용자에게 웹 페이지를 보여 준다