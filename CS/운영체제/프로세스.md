# 프로세스와 스레드

## 프로세스

**프로세스(process)**는 컴퓨터에서 실행 중인 하나의 프로그램을 의미.  
프로그램은 특정 작업을 수행하기 위한 명령어의 집합. OS는 프로그램을 실행하면서 디스크에 저장된 데이터를 메모리로 로드한다. 프로세스는 OS로부터 독립된 메모리 영역(코드, 데이터, 스택, 힙)을 할당 받으며, 다른 프로세스의 메모리 영역에 접근할 수 없다.

프로세스에 할당된 메모리 영역, PCB는 프로세스 제어블록 

- **스택(stack)**  
지역 변수, 함수의 매개변수(parameter),  
반환되는 주소 값 등이 저장되는 영역, 높은 주소 값에서 낮은 주소 값으로 메모리 할당, 영역 크기는 컴파일 때 결정
- **힙(heap)**  
사용자 의해 동적 메모리 할당이 일어나는 영역.  
C 언어에서 `malloc()`으로 할당 영역, 낮은 주소 값에서 높은 주소 값으로 메모리가 할당, 영역 크기는 런타임 때 결정.
- **데이터(data)**  
전역 변수, 정적 변수, 배열, 구조체 등 저장되는 영역.  
데이터 영역은 세부적으로 BSS(Block Stated Symbol)영역과 데이터 영역으로 다시 나눌 수 있다.  
BSS 영역은 초기화하지 않은 변수를, 데이터 영역은 초기화한 변수를 저장.
- **코드(code)**  
실행할 코드가 기계어로 컴파일되어 저장되는 영역, 테스트(text) 영역이라고 한다.

스택 영역과 힘 영역은 동적으로 메모리 할당이 간으해 두 영역 사이에 빈 메모리 공간이 존재. 스택 영역은 LIFO(Last In First Out, 후입선출) 방식, 높은 주소 값에서 낮은 주소 값 순서로 사용. 힙 영역은 FIFO(First In First Out, 선입선출) 방식으로, 낮은 주소 값에서 높은 주소 값 순서로 사용

메모리 영역을 공유하기 때문에 서로의 영역을 침범하는 문제 생길 수 있다.  
스택 영역이 힙 영역을 침범하는 경우, **스택 오버플로(stack overflow)**, 힙 영역이 스택 영역을 침법하는 경우, **힙 오버플로(heap overflow)**.

---

**오버플로(overflow)**  
메모리 공간에서 할당할 수 있는 최대 범위를 넘어가는 것을 의미.

**언더플로(underflow)**  
메모리 공간에서 할당할 수 있는 최소 범위보다 작은 것을 의미.

---

## 스레드

프로세스는 한 개 이상의 스레드를 갖는데,   
**스레드(thread)**는 프로세스에서 실제로 실행되는 흐름의 단위를 의미. 스레드는 프로세스 안에 존재하므로 프로세스의 메모리 공간을 이용, 지역 변수를 저장하는 스택 영역을 할당받는다. 그리고 전역 변수를 저장하는 힙 영역은 다른 스레드와 공유.

---

**커널과 시스템 콜**에서 커널에서 관리하는 자원을 보호하기 위해 내부적으로 사용자 모드와 커널 모드로 구분.  
마찬가지로 스레드도 스레드를 관리하는 주체에 따라 구분. 

**사용자 레벨 스레드(user-level thread)**는 사용자가 라이브러리를 이용해 생성 및 관리.  
**커널 레벨 스레드(kernel-level thread)**는 커널이 스레드를 생성 및 관리.

멀티 스레드 환경에서 사용자 레벨 스레드와 커널 레벨 스레드는 다음과 같이 3가지 관계를 맺을 수 있음

1. **다대일 모델(many-to-one model)**  
사용자 레벨 스레드 n개에 커널 레벨 스레드 1개가 매핑되어 사용자 레벨에서 스레드를 관리한다.  
하나의 사용자 레벨 스레드에서 시스템 콜을 호출하면 나머지 사용자 레벨 스레드는 커널 레벨에 접근할 수 없으므로 멀티 코어의 병령성을 이용할 수 없다.
2. **일대일 모델(ont-to-one model)**  
사용자 레벨 스레드 1개에 커널 레벨 스레드 1개가 매핑.  
이 방식은 하나의 사용자 레벨 스레드에서 시스템 콜을 호출하면 다른 사용자 레벨 스레드가 모두 실행되지 않는 다대일 모델의 단점을 해결. 하지만, 사용자 레벨 스레드 수만큼 커널 레벨 스레드가 생성되므로 성능 저하가 일어날 수 있다.
3. **다대다 모델(many-to-many model)**  
사용자 레벨 스레드 n개에 커널 레벨 스레드 m개가 매핑 된다.  
이 때 커널 레벨 스레드의 수(m)는 사용자 레벨 스레드의 수(n) 이하.   
이 방식은 다대일 모델과 일대일 모델의 장점을 포함하지만, 구현이 어렵다는 단점이 있다.

# PCB

OS는 프로세스를 제어하기 위해 프로세스 정보를 저장, 이를 **PCB(Process Control Block, 프로세스 제어 블록).** PCB는 프로세스의 현재 상태, 프로세스를 나타내는 고유의 PID(Process ID), 부모 프로세스의 PID, 자식 프로세스의 PID, 다음 실행할 명령어의 주소인 PC(Program Counter, 프로그램 카운터), 프로세스의 우선 순위, 메모리 제한 등을 저장.

---

**PCB 저장 정보**

- 포인터
- 프로세스 상태
- PID
- PC
- 레지스터
- 메모리 제한
- 열린 파일 목록
- . . .

---

# 프로세스의 생성

새로운 프로세스는 기존 프로세스에서 `fork()` 함수를 호출해 생성.  
`fork()` 함수에는 함수를 호출한 프로세스를 복사하는 기능. 이 때 기존 프로세스를 부모(parent) 프로세스, 복사된 프로세스를 자식(child) 프로세스라고 한다. 부모 프로세스에서 `fork()` 함수를 호출.  
부모 프로세스는 자식 프로세스의 PID 값을, 자식 프로세스는 0을 반환.

---

운영체제가 프로세스를 종료하는 경우는 다음과 같다

- 프로세스가 운영체제의 종료 서비스(`exit()`) 호출해 정상 종료하는 경우
- 프로세스의 실행 시간 또는 특정 이벤트 발생을 기다리는 시간이 제한된 시간을 초과한 경우
- 프로세스가 파일 검색 또는 입출력에 실패하는 경우
- 오류가 발생하거나 메모리 부족 등이 발생하는 경우

부모 프로세스는 다음과 같은 경우 자식 프로세스를 종료시킬 수 있다.

- 자식 프로세스가 할당된 자원을 초과해 사용할 때
- 자식 프로세스에 할당된 작업이 없을 때

---

## fork 함수의 반환값

`fork()` 함수의 반환값이 2개라는 부분 이해하기 어려울 수 있으니 시스템 콜을 호출하는 코드를 보고 이해해 보자.

```c
#include <stdio.h>
#include <unistd.h>

in main() {
	printf("start!\n");
	int forRet = fork();
	if (forRet == 0) {
		printf("child process %d\n", getpid());
	} else{
		printf("forkRet : %d parent process:%d\n", forkRet, getpid());
	}
	return 0;
}
```

앞의 코드 실행하면 다음과 같은 결과 나옴

```c
start!
forkRet:136 parent process:135
child proess 136
```

start!는 부모 프로세스에 의해 한 번 출력.  
부모 프로세스가 `fork()` 함수 호출하면 반환 값은 자식 프로세스의 PID인 136이 된다.  
따라서 else문으로 가서 forkRet 값과 본인(부모 프로세스)의 PID 출력. 자식 프로세스는 부모 프로세스가 fork() 함수를 호출한 시점에 생성, 반환값이 0이므로 첫 번째 조검누인 `forkRet == 0` 만족.  
따라서 본인(자식 프로세스)의 PID 출력하고 종료된다.

---

# 프로세스 상태도

모든 프로세스는 CPU에 의해 생성되고 소멸하는 과정 거침.  
이 과정에서 프로세스는 **생성(new), 준비(ready), 대기(waiting), 실행(running), 종료(terminated)라는 5가지 상태로 존재.**

- **생성(new)**  
프로세스가 PCB를 가지고 있지만 OS로부터 승인(admit) 받기 전
- **준비(ready)**  
OS로부터 승인받은 후 준비 큐에서 CPU 할당을 기다림
- **대기(waiting)**  
프로세스가 입출력이나 이벤트 발생을 기다려야 해서 CPU 사용을 멈추고 기다림
- **종료(terminated)**  
프로세스 실행을 종료함

프로세스는 한 상태에서 다른 상태로 다음과 같이 변화

- **생성 → 준비**  
생성 상태의 프로세스가 OS로부터 승인 받아,  
준비 상태의 프로세스가 모여 있는 자료구조인 준비 큐(ready queue)에 추가
- **준비 → 실행**  
준비 큐에 있는 프로세스 중 우선순위가 높은 프로세스가 디스패치(dispatch)되어 실행됨
- **실행 → 준비**  
CPU 독점을 방지하기 위해 타임아웃(timeout)되어 준비 상태로 변경됨
- **실행 → 대기**  
입출력 또는 이벤트 때문에 대기 상태로 변경됨
- **대기 → 준비**  
입출력 또는 이벤트가 완료되어 준비 상태로 변경됨
- **실행 → 종료**  
실행 중인 프로세스가 정상적으로 끝나서 종료 상태로 변경됨

---

**승인(admit)**  
CPU를 제외한 다르 자원이 준비되어 해당 프로세스가 준비 상태가 될 수 있도록 OS가 허락하는 것을 의미. 

**디스패치(dispatch)**  
프로세스에 CPU 자원을 할당해 해당 프로세스가 준비 상태에서 실행 상태가 되는 것을 의미.

# 멀티 프로세스와 멀티 스레드

멀티 프로세스와 멀티 스레드 개념을 이해하려면 동시성과 병렬성을 알아야 한다. 

**동시성(concurrency)**은 **하나의 코어(싱글 코어)에서 여러 작업을 번갈아 가면서 처리하는 방식**.  
CPU는 한 번에 하나의 작업만 처리할 수 있어서 여러 작업을 조금씩 돌아가면서 처리. 이렇게 하나의 CPU에서 여러 작업을 번갈아 가면서 처리하기 위해 처리 중인 작업을 교체하는 것을 **콘텍스트 스위칭(context switching)**.

**병렬성(parallelism)**은 **CPU가 여러 개(멀티 코어) 있어서 각 CPU에서 각 작업을 동시에 처리하는 방식**.  
즉, 물리적인 시간 관점에서 동시에 여러 작업 처리.

## 멀티 프로세스

**멀티 프로세스(multi process)**는 응용 프로그램 하나를 여러 프로세스로 구성하는 것을 의미.    
멀티 프로세스 호나경에서는 한 프로세스가 죽어도 다른 프로세스에 영향을 주지 않는다. 그래서 **응용 프로그램을 프로세스 하나로 구성하는 것보다 여러 개로 구성하는 것이 안정적**.

하지만 **시간과 메모리 공간을 많이 사용한다는 단점.**

CPU는 하나의 작업만 처리, 그래서 여러 프로세스를 처리하려면 CPU에서 처리 중인 프로세스를 교체하는 콘텍스트 스위칭 작업이 이루어져야 한다. 이 때 CPU에서 기존에 처리하던 프로세스가 할당받은 메모리 영역을 다른 프로세스에서 사용할 수 있게 교쳐하면서 시간과 메모리가 필요,  
이를 **오버헤더(overhead)**

프로세스는 독립적인 메모리 할당.  
프로세스 간에 공유할 자원이 있다면 **IPC(Inter Process Communication)**를 통해 프로세스 간에 자원을 공유. 그래서 공유할 메모리를 직접 참조하는 것보다 비효율적.

## 멀티 스레드

**멀티 스레드(multi thread)**는 스레드를 여러 개 생성해 스레드들이 각자 다른 작업을 처리하는 것을 의미.  
멀티 스레드는 스레드 간에 힙, 데이터, 모드 영역을 공유. 콘텍스트 스위칭할 때 오버헤드가 적게 발생하고 IPC 사용하지 않아도 되어 멀티 프로세스의 단점 보완.  
따라서 독립적인 메모리 공간을 갖는 프로세스를 여러 개 생성하는 것보다 스레드를 여러 개 생성하는 것이 자원을 효율적으로 사용. 그리고 스레드 간 자원 공유가 프로세스 간 자원 공유보다 시스템 처리 비용이 적고 프로그램 응답 시간도 단축된다.

하지만 스택 영역을 다른 스레드와 함께 사용하므로 공유 자원에 대한 동기화가 필수.  
스레드에 문제가 생기면 프로세스 내 다른 스레드에 영향 미칠 수 있음

# 콘텍스트 스위칭

콘텍스트 스위칭을 이해하려면 **인터럽트(interrupt)**를 알아야 한다.  
interrupt는 우리말로 ‘방해핟, 중단시키다’라는 뜻, CPU에서 프로세스를 처리하다가 **입출력 관련 이벤트가 발생하거나 예외 상황이 발생할 때 이에 대응할 수 있게 CPU에 처리를 요청하는 것**을 의미.  
인터럽트가 발생하는 경우는 입출력 발생하 때, CPU 사용 시간 만료되었을 때, 자식 프로세스를 생성할 때.

CPU 하나의 프로세스만 처리할 수 있으므로 멀티 프로세스를 처리하려면 CPU 스케줄러에 의해 인터럽트가 발생하면서 콘텍스트 스위칭이 이뤄진다.  
여기서 **콘텍스트(context)**는 CPU가 처리하는 프로세스의 정보를 의미.  
즉, **멀티 프로세스 환경에서 CPU가 처리 중인 프로세스의 정보를 바꾸는 것**이 콘텍스트 스위칭.

처리 중인 프로세스르 P1, 다음에 처리해야 하는 프로세스를 P2라고 할 때,  
CPU가 P1을 처리하던 중 운영체제에 의해 인터럽트가 발생. 그러면 P1은 유휴 상태(idle)로 변하고 스케줄러는 레지스터에 있는 처리중인 작업 정보 P1의 PCB에 저장, 그리고 P2의 PCB에 있는 정보 가져와 레지스터에 로드하고 CPU는 P2 처리하기 시작

그런데 P1의 정보를 P1의 PCB에 저장, P2의 PCB 에 저장된 정보를 레지스터에 로드하는 동안 CPU는 아무 일도 못 하게된다.  
이처럼 어떤 처리를 하는 데 간접적인 처리 시간과 메모리가 소요될 경우에 ‘오버헤드가 발생한다’고 한다

멀티 스레드를 처리할 때도 콘텍스트 스위칭이 이뤄진다.  
하지만 멀티 프로세스의 콘텍스트 스위칭보다 시간과 메모리 자원을 적게 사용. 멀티 스레드는 스택을 제외한 힙, 데이터, 코드 영역을 공유하므로 레지스터에 저장하고 로드해야 하는 데이터가 상대적으로 적기 때문

CPU에서 처리 중인 프로세스가 중간에 변경되어도 이전에 실행하던 코드를 이어서 실행할 수 있는 이유는 PCB에 프로그램 카운터와 스택 포인터 ㄱ밧이 저장되어 있기 때문. **프로그램 카운터(PC, Program Counter)**는 **프로세스가 이어서 처리해야 하는 명령어의 주소 값**, **스택 포인터(stack pointer)**는 **스택 영역에서 데이터가 채워진 가장 높은 주소 값**을 가리킨다.  
이어서 실행할 명령어의 주소 값이 무엇인지, 데이터가 스택에 어디까지 채워져 있는지 알고 있으므로 콘텍스트 스위칭이 원활히 이뤄질 수 있다.

# 프로세스 동기화

## 경쟁 상태

여러 프로세스 또는 스레드에서 하나의 공유 자원에 접근하는 경우가 있음,   
이때 자원에 접근하는 순서에 따라 결과 값이 달라질 수 있다. 이러한 현상을 **공유 자원에 동시에 접근해 경쟁하는 상태**라고 해서 **경쟁 상태(race condition)**라고 한다.

경쟁 상태의 대표적인 예로 너무 많은 우유 문제(too much milk problem)가 있다.  
냉장고에 우유가 다 떨어져서 새로사야하는 상황 가정.

---

프로세스 | 엄마, 아빠

공유 자원 | 우유

1. 엄마가 냉장고를 열어 우유가 없는 것을 확인한다.
2. 엄마가 우유를 사러 슈퍼마켓에 간다.
3. 엄마가 우유를 사서 집에 돌아오는 길에 아빠가 냉장고에 우유가 없는 것을 학인한다.
4. 아빠가 우유를 사러 슈퍼마켓에 간다.
5. 아빠가 우유를 사서 집에 돌아온다.

---

우유 1개면 충분, 2개가 되어 문제가 발생.  
우유가 0개에서 1개가 되는 것을 기대했지만 엄마가 우유를 사러 간지 모르고 아빠가 우유를 사러감으로써 우유는 총 2개가 되는, 의도하지 않은 결과를 초래.  
이러한 문제를 해결하려면 프로세스 동기화가 이뤄져야 한다.

## 임계영역

공유 자원에 접근할 수 있고 접근 순서에 따라 결과가 달라지는 코드 영역을 **임계 영역(critical section).** 냉장고에 우유 유무를 판단하고 우유를 추가하는 부분이 임계 영역에 해당. 임계 영역에서 경쟁 상태가 발생하는 것을 방지하려면 여러 프로세스가 공유 자원에 접근해도 데이터의 일관성이 유지되도록 **프로세스 동기화(process synchronization)**를 해야 한다.

임계 영역에 여러 접근이 동시에 발생하는 것을 방지하려면 다음 3가지 조건을 충족.

- **상호배제 기법(mutual exclusive)**  
어떤 프로세스가 임계 영역을 실행 중일 때 다른 프로세스가 임계 영역에 접근할 수 없다.  
상호배제 기법으로는 뮤텍스와 세마포어가 있다.
- **진행(progress)**  
임계 영역을 실행 중인 프로세스가 없을 때 다른 프로세스가 임계 영역을 실행한다.
- **한정된 대기(bounded waiting)**  
임계 영역에 접근을 요청했을 때 무한한 시간을 기다리지 않는다.

## 뮤텍스

**뮤텍스(mutex)**는 **락(lock)을 가진 프로세스만이 공유 자원에 접근할 수 있게 하는 방법**.  
개념을 이해하기 위한 예시

---

1. 식당에는 화장실 한 칸과 화장실 문을 열 수 있는 열쇠 한 개가 있다.
2. A가 열쇠를 가지고 화장실에 간다.
3. 화장실에 가려던 B는 열쇠가 없어서 기다린다.
4. A가 화장실에서 나와 열쇠를 반납하면, 기다리던 B가 열쇠를 가지고 화장실에 간다.

---

화장실은 공유 자원을 포함한 임계 영역을, 열쇠는 락을, A, B는 공유 자원에 접근하려는 프로세스를 의미한다. 임계 영역에 먼저 접근한 프로세스가 임계 영역에 락을 걸면 다른 프로세스들은 해당 프로세스가 락을 해제하기 전까지 대기.  
이 처럼 임게 영역에 접근한 프로세스가 임계 영역에 락을 건다고 해서 **락킹 매커니즘(locking mechanism)**이라고 한다.

임계 영역에 접근하지 못한 프로세스는 락을 얻기 위해 기다리는 동안 락이 풀렸는지 반복문을 돌면서 확인. 이를 **바쁜 대기(busy waiting)**의 한 종류인 스핀락이라고 한다.  
즉, **스핀락(spinlock)**은 락을 얻기 위해 프로세스가 반복문을 돌면서 기다리는 것을 의미한다.  
프로세스가 대기 상태가 되지 않고 반복문을 돌면서 자원의 사용 가능 여부를 확인하므로 프로세스가 빠르게 교체될 수 있다.

---

**바쁜 대기(busy waiting)**  
프로세스가 공유 자원에 접근할 수 있는 권한을 얻을 때까지 확인하는 과정을 일컫는다.

---

## 세마포어

**세마포어(semaphore)**는 **공유 자원에 접근할 수 있는 프로세스의 수를 정해 접근을 제어하는 방법.**  
세마포어의 작동 방식을 화장실 예에 비유하면

---

1. 식당에 화장실 3칸, 화장실을 열 수 있는 열쇠가 3개
2. A가 화장실 열쇠 하나를 가지고 화장실에 간다. 열쇠는 2개가 남는다.
3. B, C가 열쇠를 하나씩 가지고 화장실에 간다. 남은 열쇠가 없어서 D는 화장실에 가지 못한다.
4. C가 화장실에서 나와 열쇠를 돌려놓으면, D가 화장실에 간다.

---

뮤텍스일 때와 동일하게 화장실은 공유 자원을 포함한 뮤텍스일 때와 동일하게 화장실은 공유 자원을 포함한 임계 영역을 의미, A, B, C, D는 공유 자원에 접근하려는 프로세스를 의미.  
화장실 개수(열쇠 개수)는 공유 자원에 접근할 수 있는 프로세스의 수를 제어하기 위한 정수 변수를 나타낸다. 임계 영역에 접근하는 방식이다.  
이 방식은 공유 자원에 접근한 프로세스가 접근을 해제하면 다른 프로세스가 접근할 수 있도록 신호를 보낸다고 해서 **시그널링 매커니즘(signaling mechanism)**이라 한다.

---

동기와 비동기, 블로킹과 넌블로킹은 작업 처리와 관련해 자주 사용하는 용어인데, 개념 헷갈림.  
동기와 비동기는 작업 순서에 대한 개념, 블로킹과 넌블로킹은 작업을 위한 대기를 구분하는 개념. 가끔 비교하는 질문이 나오므로 개념을 알아 두어야 한다.

- **동기(synchronization)**  
여러 작업을 처리할 때 작업 순서를 보장함
- **비동기(asynchronization)**   
여러 작업을 처리할 때 작업 순서를 보장하지 않음
- **블로킹(blocking)**  
작업을 수행할 때 대기할 수 있다는 것을 의미하며 작업 순서를 보장하지 않음
- **넌블로킹(non-blocking)**  
작업을 시작하면 대기 없이 수행한다는 것을 의미함

# 교착 상태

상호배제 기법 때문에 **2개 이상의 프로세스가 각각 자원을 가지고 있으면서 서로의 자원을 요구하며 기다리는 상태**를 **교착 상태(deadlock)**라고 한다.  
교착 상태가 발생하는 4가지 필요 충분 조건이 있다.

- **상호배제(mutua exclusion)**  
하나의 공유 자원에 하나의 프로세스만 접근할 수 있다.
- **점유와 대기(hold and wait)**  
프로세스가 최소 하나의 자원을 점유하고 있는 상태에서 추가로 다른 프로세스에서 사용 중인 자원을 점유하기 위해 대기한다.
- **비선점(non-preemption)**  
다른 프로세스에 할당된 자원을 뺏을 수 없다.
- **환형 대기(circular wait)**  
프로세스가 자신의 자원을 점유하면서 앞이나 뒤에 있는 프로세스의 자원을 요구한다.

**교착 상태를 막으려면 앞의 4가지 필요 충분 조건 중에서 한 가지를 제거**하면 된다.

- **상호배제 부정**  
여러 프로세스가 동시에 하나의 공유 자원을 사용할 수 있게 한다.
- **점유와 대기 부정**  
프로세스가 실행되기 전에 필요한 모든 자원을 할당함으로써 프로세스 대기를 없앤다.  
또는 프로세스가 자원을 점유하지 않은 상태에서만 자원을 요구하게 한다.
- **비선점 부정**  
자원을 점유한 프로세스가 다른 자원을 요구할 때 점유한 자원을 반납하게 한다.
- **환형 대기 부정**  
자원을 선형 순서로 정렬해 고유 번호를 할당한다.  
그리고 각 프로세스에서 요구할 수 있는 번호의 방향을 정해서 한쪽 방향으로만 자원을 요구하게 한다.

---

교착 상태의 필요 충분 조건은 외우지 않고 이해하는 것이 좋다.  
각 프로세스를 사람이라고 생각하면 이해하기 쉽다. 프로세스 1이 자원 1을, 프로세스 2가 자원 2를 가지고 있는 상황이다. 프로세스 1은 자원 2가 필요, 프로세스 2는 자원 1이 필요해 교착 상태가 발생.

- **상호배제**  
하나의 공유 자원에 대해 하나의 프로세스만 사용할 수 있다는 개념.  
만약 하나의 공유 자원을 여러 프로세스가 공유할 수 있다면 위와 상황은 성리할 수 없다.  
따라서, 지원을 공유할 수 있게 되면 서로의 자원을 기다리는 상황을 예방할 수 있다
- **점유와 대기**  
하나의 프로세스가 이미 자원을 가진 상태에서 다른 프로세스의 자원을 갖기 위해 기다리는 상황.  
프로세스가 자원을 요구할 때 필요한 자원 1과 자원 2를 모두 주거나 가진 자원이 없는 경우에만 자원을 할당함으로써 문제를 해결할 수 있다.
- **비선점**  
다른 프로세스가 가지고 있는 자원을 뺏을 수 없다는 개념.  
프로세스 1이 프로세스 2의 자원을 뺏을 수 있게 한다면 서로의 자원을 갖기 위해 대기하는 상황을 예방할 수 있다.
- **환형 대기**  
프로세스 1이 프로세스 2의 자원을 요구, 프로세스 2가 프로세스 1의 자원을 요구함으로써 생긴다. 위와 같이 각자의 자원을 가진 상태에서 상대방의 자원을 요구하는 상황.  
이때 작은 번호 프로세스가 큰 번호 프로세스의 자원을 요구하는 것만 가능하게 한다면 프로세스 2가 프로세스 1의 자원을 요구할 수 없게 되므로 환형 대기를 없앨 수 있다.

# 스레드 안전

**스레드 안전(thread safe)**은 멀티 스레드 환경에서 **하나의 변수, 함수, 객체에 스레드 여러개가 동시에 접근해도 문제가 없음을 의미**한다. 스레드 안전하지 않은 경우는 다음과 같이 간단한 코드에서도 나타난다.

---

var++;

---

이 코드는 var 변수의 값을 메모리에서 CPU 레지스터로 로드 → 연산 처리 → 연산 결과를 메모리에 작성하는 과정을 거치게 된다.  
만약 이 코드에 스레드 2개가 접근하면 잘못된 결과를 초래할 수 있다.

---

## case 1

### **스레드 1**

var 값을 메모리에서 CPU 레지스터로 로드 (var = 0)

연산 수행 (var = 1)

var 값을 메모리에 저장 (var = 1)

### **스레드 2**

var 값을 메모리에서 CPU 레지스터로 로드 (var = 0)

연산 수행 (var = 1)

var 값을 메모리에 저장 (var = 1)

== **var = 1**

---

## case 2

### **스레드 1**

var 값을 메모리에서 CPU 레즈스터로 로드 (var = 0)

연산 수행 (var = 1)

var 값을 메모리에 저장 (var = 1)

### 스레드 2

var 값을 메모리에서 CPU 레지스터로 로드 (var = 1)

연산 수행 (var = 2)

var 값을 메모리에 저장 (var = 2)

== **var = 2**

---

이처럼 한 줄짜리 코드에서도 스레드 2개가 접근하면 예상 밖의 결과.  
**프로세스 동기화**에서 이야기한 너무 많은 우유 문제도 스레드 안전하다고 할 수 없다.

---

### 스레드 안전을 위한 조건

스레드 안전하기 위해서는 다음과 같은 조건을 지켜야 한다.

- **상호배제(mutual exclusive)**  
공유 자원에 접근해야 할 때 뮤텍스 또는 세마포어와 같은 상호배제 기법을 사용해 접근을 통제해야 한다.
- **원자 연산(atomic operation)**  
공유 자원에 접근할 때 원자 연산을 이용하거나 원자적으로 정의된 연산을 이용해 연산 도중에 다른 스레드가 접근할 수 없게 한다. 여기서 원자 연산이란 ‘연산했다’와 ‘연산 안 했다’ 두 가지만 존재하는 연산.
- **재진입성(reentrancy)**  
특정 함수를 하나의 스레드에서 실행 중일 때 다른 스레드가 해당 함수를 실행해도 각 스레드에 올바른 결과가 나올 수 있게 해야 한다.
- **스레드 지역 저장소(thread local storage)**   
각 스레드에서만 접근할 수 있는 저장소를 사용해서 공유되는 자원을 줄어야 한다.

# IPC

프로세스는 고유한 메모리 영역을 갖기 때문에 프로세스 간 자원을 공유해야 할 때 IPC 해야 한다.  
IPC는 Inter Process Communication의 약자로, 프로세스 간에 자원을 공유하는 방식.  
대표적인 종류

- **공유 메모리(shared memory)**   
프로세스 간에 공유 가능한 메모리를 구성해 자원을 공유하는 방식.  
여러 프로세스에서 접근할 수 있으므로 동기화 문제가 발생할 수 있다
- **소켓(socket)**  
네트워크 소켓을 이요하는 프로세스 간 통신으로, 외부 시스템과도 이용할 수 있다.  
클라이언트(client)와 서버(server) 구조로 자원을 주고 받는다.
- **세마포어(semaphore)**  
접근하는 프로세스를 제어해 공유 자원을 관리한다.
- **파이프(pipe)  
FIFO(First In Out)** 형태의 메모리인 파이프를 이용해 프로세스 간 자원을 공유하는 방식.  
파이프는 단방향 통신만 지원하므로 읽기 또는 쓰기 중 하나만 할 수 있다. 따라서 양방향 통신을 하려면 읽기 파이프(read pipe)와 쓰기 파이프(write pipe)를 각각 생성 해야 한다.
- **메시지 큐(message queue)**  
FIFO 형태의 큐 자료구조를 사용해 프로세스 간 메시지를 주고받는 방식이다.

# 좀비 프로세스와 고아 프로세스

자식 프로세스가 종료되었지만 **부모 프로세스가 자식 프로세스의 종료 상태를 회수하지 않았을 경우에 남겨진 자식 프로세스**를 **좀비 프로세스(zombie process)**라고 한다.  
자식 프로세스가 종료될 때 부모 프로세스 `SIGCHLD`라는 시그널을 보내면 부모 프로세스에서 `wait()` 함수(시스템 콜)를 호출해 자식 프로세스의 상태 정보를 받고 자원을 회수한다.  
이 때 자원 회수에 실패하면 좀비 프로세스가 생기게 된다. 좀비 프로세스가 쌓이면 자원이 낭비될 수 있다.

**부모 프로세스가 자식 프로세스보다 먼저 종료되는 경우에 자식 프로세스**를 **고아 프로세스(orphan process)**라고 한다. 이럴 때는 자식 프로세스의 부모 PID를 init 프로세스(부팅 시 가장 먼저 실행되는 프로세스)의 PID인 1로 바꿔 준다. 이렇게 하면 고아 프로세스의 부모 프로세스는 init 프로세스가 된다. 이후 고아 프로세스가 작업을 종료하면 init 프로세스가 고아 프로세스의 자원을 회수해 좀비 프로세스가 되는 것을 방지할 수 있다.