# 논리 메모리와 물리 메모리

CPU가 프로세스를 처리할 때 보는 주소 값과 실제 메모리의 주소 값은 다르다.  
프로세스가 보는 메모리 영역을 **논리 메모리 영역(logical memory address space)** 또는 **가상 메모리 영역(virtual memory address space)**이라고 한다. 그리고 CPU가 프로세스를 실행하며 보는 주소 값을 **논리 주(logical address)** 또는 **가상 주소(virtual address)**라고 하며, 실제 메모리에서 사용되는 주소는 **물리 주소(physical address)**라고 한다.

CPU가 프로세스를 실행할 때 사용하는 주소 값과 실제 주소 값이 다르므로 논리 주소를 물리 주소로 변환해 줘야 하는데, 이러한 동작을 하는 하드웨어 장치를 **메모리 관리 장치(MMU, Memory Management Unit)**라고 한다. MMU는 CPU에 위치하며, CPU에서 메모리에 접근하기 전에 MMU를 거쳐 논리 주소에 해당하는 물리 주소를 얻는다. MMU는 보호해야 하는 메모리 영역에 대한 접근을 제한해 메모리를 보호하는 역할.

MMU 작동 방식을 정리.

---

CPU → (논리 주소) → MMU → (물리 주소) → RAM

RAM → (데이터) → CPU

---

# 연속 메모리 할당

**연속 메모리 할당(contiguous allocation)**은 멀티 프로세스 환경에서 여러 프로세스를 메모리에 연속적으로 로드하는 방법.   

연속 메모리 할당 2가지 방식.

## 고정 분할 방식

고정 분할은 **메모리 영역을 분할한 뒤 각 영역에 프로세스를 할당**. 이때 분할된 영역의 크기는 서로 다를 수 있으며, 분할된 크기는 고정. 그런데 이 방식은 메모리에 올릴 수 있는 프로세스 수와 각 프로세스 크기가 제한된다는 단점, **단편화(fragmentation)** 문제 발생.

예를 들어, 8MB의 메모리 공간과 2MB의 메모리 공간을 합치면 프로세스 7에 공간을 할당할 수 있지만, 고정 분할 때문에 할당하지 못한. 이런 경우를 **외부 단편화(external fragmentation)**라고 한다. 그리고 프로세스 3과 4 처럼 분할된 크기보다 작은 프로세스가 할당되어 메모리 공간이 남는 경우를 **내부 단편화(internal fragmentation)**.

## 가변 분할 방식

가변 분할 **할당할 프로세스의 크기에 따라 메모리 공간을 분할**하는 방식.  
이 방식은 메모리 할당 알고리즘을 이용해 가용 메모리 공간에서 프로세스가 로드될 수 있는 메모리 공간. 메모리 할당 알고리즘으로는 최초 적합, 최적 적합, 최악 적합 등이 있다.

- **최초 적합(first-fit)**  
가용 메모리 공간에서 프로세스 크기만큼 비어 있는 메모리 공간을 찾아 차례대로 프로세스를 로드하는 방식
    1. 20MB의 프로세스 1이 56MB의 가용 메모리 공간에 할당
    2. 18MB의 프로세스 2가 36MB의 가용 메모리 공간에 할당
    3. 12MB의 프로세스 3이 18MB의 가용 메모리 공간에 할당
    4. 메모리 영역에서 프로세스 2의 할당이 해제
    5. 6MB의 프로세스 4를 할당할 수 있는 가용 메모리 공간을 찾으면 가장 먼저 18MB의 메모리 공간 탐색. 그러면 더 이상 탐색을 진행하지 않고 프로세스 4를 해당 메모리 공간에 할당
- **최적 적합(best-fit)**  
할당하려는 프로세스 크기 이상인 가용 메모리 공간 중에서 가장 작은 공간에 프로세스를 할당하는 방식.  
이 방식은 가용 메모리 공간을 모두 탐색.
    1. 20MB의 프로세스 1이 56MB의 가용 메모리 공간에 할당
    2. 18MB의 프로세스 2가 36MB의 가용 메모리 공간에 할당
    3. 12MB의 프로세스 3이 18MB의 가용 메모리 공간에 할당
    4. 메모리 영역에서 프로세스  2의 할당 해제
    5. 6MB의 프로세스 4를 할당할 수 있는 가용 메모리 공간을 찾으면 18MB와 6MB의 공간이 탐색.   
    이 중 가장 작은 6MB의 메모리 공간에 프로세스 4가 할당
- **최악 적합(worst-fit)**  
할당하려는 프로세스 크기보다 큰 가용 메모리 공간 중에서 가장 큰 공간에 프로세스를 할당하는 방식.  
최적 적합 방식과 마찬가지로 가용 메모리 공간을 모두 탐색
    1. 20MB의 프로세스 1이 56MB의 가용 메모리 공간에 할당
    2. 18MB의 프로세스 2가 36MB의 가용 메모리 공간에 할당
    3. 12MB의 프로세스 3이 18MB의 가용 메모리 공간에 할당
    4. 메모리 영역에서 프로세스  2의 할당 해제
    5. 6MB의 프로세스 4를 할당할 수 있는 가용 메모리 공간을 찾으면 18MB와 6MB의 공간이 탐색.   
    이 중 가장 작은 18MB의 메모리 공간에 프로세스 4가 할당

---

외부 단편화 문제를 해결하는 방법으로 **메모리 압축(memory compaction)**. 메모리 압축은 프로세스가 사용 중인 메모리 공간을 재배치해서 흩어져 있는 가용 메모리 공간을 하나로 합치는 것으로 메모리 집약.

흩어져 있는 가용 메모리 공간 중에서 프로세스 7이 들어갈 수 있는 공간은 없다.  
이대 메모리 압출을 수행하면 14MB의 가용 공간이 생기므로 외부 단편화 문제를 해결하고 프로세스 7을 메모리에 로드할 수 있게 된다.

# 비연속 메모리 할당

비연속 메모리 할당은 프로세스의 메모리 영역을 나눠서 메모리 공간에 저장하는 방법으로,  
페이징과 세그먼테이션이라는 2가지 방식.

## 페이징

**페이징(paging)** 기법은 **프로세스의 논리 메모리 영역과 물리 메모리 영역을 각각 일정한 크기의 페이지(page)와 프레임(frame)으로 나눈다.** 이때 페이지와 프레임 크기는 동일. 페이지와 프레임에는 각각 번호를 할당해 프로세스의 페이지와 메모리의 프레임을 매핑.

페이지와 프레임을 매핑하는 데는 **페이지 테이블(page table)**을 사용.  
페이지 테이블은 프로세스의 페이지 정보와 페이지에 매핑하는 프레임의 주소 값을 저장. 페이지 테이블은 각 프로세스 PCB에 저장

페이징 기법이 작동하는 방식은 다음과 같다

페이징 기법을 사용하면 페이지를 물리 메모리에 연속으로 할당할 필요가 없어서 외부 단편화 문제를 해결할 수 있다. 하지만 프로세스 크기가 페이지 수로 나누어 떨어지는 보장하지 않는다. 따라서 프로세스의 마지막 페이지가 페이지 크기보다 작을 수 있으므로 내부 단편화 문제가 발생할 수 있다.  
또한, 페이지 테이블을 저장하기 위한 메모리 공간이 추가로 필요.

---

**페이지 기법 3가지**

- **계층적 페이징(hierarchical paging)**    
페이징 테이블을 다시 페이지로 나눠 페이지 테이블 자체를 페이징하는 방식, 멀티 레벨 페이징(multi-level paging)이라고 한다.
- **해시 페이지 테이블(hashed page table)**  
해시 테이블의 각 항목에 저장된 연결 리스트에 페이지 번호를 해싱(hashing)한 뒤에 첫 번째 요소와 가상 페이지 번호를 비교하는 방식
- **역 페이지 테이블(inverted page table)**  
프레임을 이용해 페이지를 찾는 방식. 페이지로 프레임을 찾는 기존 방식과 방대다

---

## 세그먼테이션

**세그먼테이션(segmentation)** 기법은 **프로세스의 메모리 영역을 논리적 단위인 세그먼트로 분할해 메모리를 할당.** 여기서 논리적 단위는 파일 내 함수 단위나 프로세스의 스택, 힙과 같은 영역을 의미.

이 기법은 **세그먼테이션(segment table)**을 사용해 세그먼트의 논리 주소를 물리 주소로 매핑.  
세그먼트 테이블은 세끄먼트 번호를 인덱스로 사용, 세그먼트별 시작 주소인 base와 세그먼트 길이인 limit를 저장.

세그먼테이션 기법은 프로세스의 메모리 영역을 논리적 단위로 나눠 저장하므로 단위 별로 데이터를 보호하기 쉽다는 장점이 있다. 하지만 세그먼트의 크기가 균등하지 않아서 프로세스의 할당/해제를 반복하는 과정에서 외부 단편화 문제가 발생. 또한, 메모리에 로드된 스택 세그먼트 영역에서 오버플로가 발생하면 다른 프로세스와 메모리 영역이 겹칠 수 있다. 그러면 다른 프로세스의 세그먼트나 스택 오버플로가 발생한 세그먼트를 디스크로 스왑 아웃해야 하는 단점.